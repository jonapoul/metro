// FILE: MultibindingsHaveConsistentOrderAcrossContributedGraph.kt

@Inject
class TaskImpl1 : Task {
  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  object MetroFactory : Factory<TaskImpl1> {
    private constructor() /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    fun create(): Factory<TaskImpl1> {
      return MetroFactory
    }

    fun newInstance(): TaskImpl1 {
      return TaskImpl1()
    }

    override operator fun invoke(): TaskImpl1 {
      return MetroFactory.newInstance()
    }

    fun mirrorFunction(): TaskImpl1 {
      return error(message = "Never called")
    }

  }

  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@Inject
class TaskImpl2 : Task {
  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  object MetroFactory : Factory<TaskImpl2> {
    private constructor() /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    fun create(): Factory<TaskImpl2> {
      return MetroFactory
    }

    fun newInstance(): TaskImpl2 {
      return TaskImpl2()
    }

    override operator fun invoke(): TaskImpl2 {
      return MetroFactory.newInstance()
    }

    fun mirrorFunction(): TaskImpl2 {
      return error(message = "Never called")
    }

  }

  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

class TaskImpl3 : Task {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

class TaskImpl4 : Task {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@DependencyGraph(scope = AppScope::class)
interface ExampleGraph : MetroContributionToAppScope {
  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  abstract class BindsMirror {
    private constructor() /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    @Binds
    @IntoSet
    @CallableMetadata(callableName = "<get-bind>", propertyName = "bind", startOffset = 313, endOffset = 337)
    abstract fun TaskImpl1.bind_intoset(): Task

    @Binds
    @IntoSet
    @CallableMetadata(callableName = "<get-bind>", propertyName = "bind", startOffset = 270, endOffset = 294)
    abstract fun TaskImpl2.bind_intoset(): Task

  }

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  @MetroImplMarker
  class Impl : ExampleGraph {
    private val thisGraphInstance: ExampleGraph
      field = <this>

    private val exampleGraphProvider: Provider<ExampleGraph>
      field = Companion.invoke<ExampleGraph>(value = <this>.#thisGraphInstance)

    @DependencyGraph(scope = Unit::class)
    inner class LoggedInGraphImpl : LoggedInGraph {
      constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      private val setOfTask: Set<Task>
        private get(): Set<Task> {
          return buildSet<Task>(capacity = 4, builderAction = local fun MutableSet<Task>.<anonymous>() {
            $receiver.add(element = Companion.create(instance = <this>).invoke())
            $receiver.add(element = Companion.create(instance = <this>).invoke())
            $receiver.add(element = <this>.<get-taskImpl1Provider>().invoke())
            $receiver.add(element = <this>.<get-taskImpl2Provider>().invoke())
          }
)
        }

      private val taskImpl1Provider: Provider<TaskImpl1>
        private get(): Provider<TaskImpl1> {
          return MetroFactory.create()
        }

      private val taskImpl2Provider: Provider<TaskImpl2>
        private get(): Provider<TaskImpl2> {
          return MetroFactory.create()
        }

      override val tasksFromParent: Set<Task>
        override get(): Set<Task> {
          return <this>.<get-setOfTask>()
        }

    }

    private constructor() /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override fun createLoggedInGraph(): LoggedInGraph {
      return <this>.LoggedInGraphImpl()
    }

    @IntoSet
    @Binds
    override val TaskImpl2.bind: Task
      override get(): Task {
        return error(message = "Never called")
      }

    @IntoSet
    @Binds
    override val TaskImpl1.bind: Task
      override get(): Task {
        return error(message = "Never called")
      }

    private val setOfTask: Set<Task>
      private get(): Set<Task> {
        return buildSet<Task>(capacity = 4, builderAction = local fun MutableSet<Task>.<anonymous>() {
          $receiver.add(element = Companion.create(instance = <this>.#thisGraphInstance).invoke())
          $receiver.add(element = Companion.create(instance = <this>.#thisGraphInstance).invoke())
          $receiver.add(element = <this>.<get-taskImpl1Provider>().invoke())
          $receiver.add(element = <this>.<get-taskImpl2Provider>().invoke())
        }
)
      }

    private val taskImpl1Provider: Provider<TaskImpl1>
      private get(): Provider<TaskImpl1> {
        return MetroFactory.create()
      }

    private val taskImpl2Provider: Provider<TaskImpl2>
      private get(): Provider<TaskImpl2> {
        return MetroFactory.create()
      }

    override val tasks: Set<Task>
      override get(): Set<Task> {
        return <this>.<get-setOfTask>()
      }

  }

  companion object Companion {
    private constructor() /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    @GraphFactoryInvokeFunctionMarker
    operator fun invoke(): ExampleGraph {
      return Impl()
    }

  }

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  @CallableMetadata(callableName = "provide3", propertyName = "", startOffset = 396, endOffset = 449)
  class Provide3MetroFactory : Factory<Task> {
    private /* final field */ val instance: ExampleGraph = instance
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(instance: ExampleGraph): Factory<Task> {
        return Provide3MetroFactory(instance = instance)
      }

      fun provide3(instance: ExampleGraph): Task {
        return instance.provide3()
      }

    }

    private constructor(instance: ExampleGraph) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): Task {
      return Companion.provide3(instance = <this>.#instance)
    }

    @IntoSet
    fun mirrorFunction(): Task {
      return error(message = "Never called")
    }

  }

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  @CallableMetadata(callableName = "provide4", propertyName = "", startOffset = 340, endOffset = 393)
  class Provide4MetroFactory : Factory<Task> {
    private /* final field */ val instance: ExampleGraph = instance
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(instance: ExampleGraph): Factory<Task> {
        return Provide4MetroFactory(instance = instance)
      }

      fun provide4(instance: ExampleGraph): Task {
        return instance.provide4()
      }

    }

    private constructor(instance: ExampleGraph) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): Task {
      return Companion.provide4(instance = <this>.#instance)
    }

    @IntoSet
    fun mirrorFunction(): Task {
      return error(message = "Never called")
    }

  }

  @IntoSet
  @Provides
  private fun provide3(): Task {
    return TaskImpl3()
  }

  @IntoSet
  @Provides
  private fun provide4(): Task {
    return TaskImpl4()
  }

  @IntoSet
  @Binds
  abstract val TaskImpl2.bind: Task
    abstract get

  @IntoSet
  @Binds
  abstract val TaskImpl1.bind: Task
    abstract get

  abstract val tasks: Set<Task>
    abstract get

}

@GraphExtension(scope = Unit::class)
interface LoggedInGraph {
  @Factory
  @ContributesTo(scope = AppScope::class)
  interface Factory1 {
    @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
    @MetroContribution(scope = AppScope::class)
    interface MetroContributionToAppScope : Factory1 {
    }

    abstract fun createLoggedInGraph(): LoggedInGraph

  }

  abstract val tasksFromParent: Set<Task>
    abstract get

}

interface Task {
}

object AppScope {
  private constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

// FILE: loggedInGraphFactory1AppScope.kt
package metro.hints

fun AppScope(contributed: Factory1) {
  return error(message = "Never called")
}

