<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=cGvuclDC_Z1vE_cnVEU6AXwt0FhZg2eM5SxmxX_Zyl69KI1qQnlY1YbF032satvGxc_kys-mkJREUI8Ymx-Ltq64FWF8npVb5gVC94dQYm0);ol.lst-kix_ulfgfs8t0p10-5.start{counter-reset:lst-ctn-kix_ulfgfs8t0p10-5 0}.lst-kix_insgc4ut8xxf-8>li:before{content:"\0025a0   "}.lst-kix_insgc4ut8xxf-7>li:before{content:"\0025cb   "}ul.lst-kix_6lpac386yqkw-0{list-style-type:none}.lst-kix_insgc4ut8xxf-6>li:before{content:"\0025cf   "}ul.lst-kix_6lpac386yqkw-1{list-style-type:none}ul.lst-kix_6lpac386yqkw-2{list-style-type:none}ol.lst-kix_hxj86hw44hwz-6.start{counter-reset:lst-ctn-kix_hxj86hw44hwz-6 0}ul.lst-kix_6lpac386yqkw-3{list-style-type:none}ul.lst-kix_6lpac386yqkw-4{list-style-type:none}ul.lst-kix_6lpac386yqkw-5{list-style-type:none}ul.lst-kix_6lpac386yqkw-6{list-style-type:none}.lst-kix_insgc4ut8xxf-5>li:before{content:"\0025a0   "}ul.lst-kix_6lpac386yqkw-7{list-style-type:none}.lst-kix_vd5udb8u1zxq-8>li{counter-increment:lst-ctn-kix_vd5udb8u1zxq-8}.lst-kix_o6z0gnpm11dy-1>li:before{content:"\0025cb   "}.lst-kix_ulfgfs8t0p10-6>li{counter-increment:lst-ctn-kix_ulfgfs8t0p10-6}ul.lst-kix_oq7so7y4wkm1-4{list-style-type:none}ul.lst-kix_oq7so7y4wkm1-5{list-style-type:none}.lst-kix_o6z0gnpm11dy-0>li:before{content:"\0025cf   "}.lst-kix_o6z0gnpm11dy-2>li:before{content:"\0025a0   "}ul.lst-kix_oq7so7y4wkm1-6{list-style-type:none}ul.lst-kix_xsdacgr1md4u-0{list-style-type:none}ul.lst-kix_oq7so7y4wkm1-7{list-style-type:none}ul.lst-kix_xsdacgr1md4u-1{list-style-type:none}.lst-kix_o6z0gnpm11dy-3>li:before{content:"\0025cf   "}ul.lst-kix_oq7so7y4wkm1-0{list-style-type:none}ul.lst-kix_xsdacgr1md4u-2{list-style-type:none}ul.lst-kix_oq7so7y4wkm1-1{list-style-type:none}ul.lst-kix_xsdacgr1md4u-3{list-style-type:none}ul.lst-kix_oq7so7y4wkm1-2{list-style-type:none}ul.lst-kix_xsdacgr1md4u-4{list-style-type:none}ul.lst-kix_oq7so7y4wkm1-3{list-style-type:none}ul.lst-kix_xsdacgr1md4u-5{list-style-type:none}ul.lst-kix_xsdacgr1md4u-6{list-style-type:none}ul.lst-kix_xsdacgr1md4u-7{list-style-type:none}ul.lst-kix_xsdacgr1md4u-8{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-8.start{counter-reset:lst-ctn-kix_vd5udb8u1zxq-8 0}.lst-kix_hxj86hw44hwz-6>li{counter-increment:lst-ctn-kix_hxj86hw44hwz-6}.lst-kix_oq7so7y4wkm1-2>li:before{content:"\0025a0   "}ul.lst-kix_dbwn88c6y82-1{list-style-type:none}ul.lst-kix_dbwn88c6y82-0{list-style-type:none}.lst-kix_oq7so7y4wkm1-1>li:before{content:"\0025cb   "}.lst-kix_oq7so7y4wkm1-3>li:before{content:"\0025cf   "}.lst-kix_x2grhxcoumgd-0>li:before{content:"\0025cf   "}.lst-kix_x2grhxcoumgd-2>li:before{content:"\0025a0   "}ul.lst-kix_dbwn88c6y82-5{list-style-type:none}ul.lst-kix_dbwn88c6y82-4{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-3.start{counter-reset:lst-ctn-kix_vd5udb8u1zxq-3 0}ul.lst-kix_dbwn88c6y82-3{list-style-type:none}ol.lst-kix_hxj86hw44hwz-0.start{counter-reset:lst-ctn-kix_hxj86hw44hwz-0 0}ul.lst-kix_dbwn88c6y82-2{list-style-type:none}.lst-kix_x2grhxcoumgd-3>li:before{content:"\0025cf   "}ul.lst-kix_dbwn88c6y82-8{list-style-type:none}.lst-kix_oq7so7y4wkm1-7>li:before{content:"\0025cb   "}ul.lst-kix_dbwn88c6y82-7{list-style-type:none}ul.lst-kix_dbwn88c6y82-6{list-style-type:none}.lst-kix_ulfgfs8t0p10-4>li{counter-increment:lst-ctn-kix_ulfgfs8t0p10-4}.lst-kix_oq7so7y4wkm1-0>li:before{content:"\0025cf   "}.lst-kix_oq7so7y4wkm1-8>li:before{content:"\0025a0   "}ul.lst-kix_oq7so7y4wkm1-8{list-style-type:none}.lst-kix_x2grhxcoumgd-1>li:before{content:"\0025cb   "}.lst-kix_vvh90m5tr5ag-2>li:before{content:"\0025a0   "}.lst-kix_insgc4ut8xxf-2>li:before{content:"\0025a0   "}ul.lst-kix_ca7bql3yx5nl-8{list-style-type:none}.lst-kix_vvh90m5tr5ag-1>li:before{content:"\0025cb   "}.lst-kix_vvh90m5tr5ag-3>li:before{content:"\0025cf   "}.lst-kix_x2grhxcoumgd-8>li:before{content:"\0025a0   "}ul.lst-kix_ca7bql3yx5nl-5{list-style-type:none}.lst-kix_vvh90m5tr5ag-0>li:before{content:"\0025cf   "}.lst-kix_vvh90m5tr5ag-4>li:before{content:"\0025cb   "}.lst-kix_insgc4ut8xxf-0>li:before{content:"\0025cf   "}.lst-kix_insgc4ut8xxf-4>li:before{content:"\0025cb   "}ul.lst-kix_ca7bql3yx5nl-4{list-style-type:none}ul.lst-kix_ca7bql3yx5nl-7{list-style-type:none}.lst-kix_insgc4ut8xxf-3>li:before{content:"\0025cf   "}ul.lst-kix_ca7bql3yx5nl-6{list-style-type:none}.lst-kix_x2grhxcoumgd-7>li:before{content:"\0025cb   "}.lst-kix_hxj86hw44hwz-8>li{counter-increment:lst-ctn-kix_hxj86hw44hwz-8}ul.lst-kix_ca7bql3yx5nl-1{list-style-type:none}.lst-kix_oq7so7y4wkm1-6>li:before{content:"\0025cf   "}ul.lst-kix_ca7bql3yx5nl-0{list-style-type:none}ul.lst-kix_ca7bql3yx5nl-3{list-style-type:none}.lst-kix_oq7so7y4wkm1-5>li:before{content:"\0025a0   "}ul.lst-kix_ca7bql3yx5nl-2{list-style-type:none}.lst-kix_x2grhxcoumgd-4>li:before{content:"\0025cb   "}.lst-kix_x2grhxcoumgd-6>li:before{content:"\0025cf   "}.lst-kix_oq7so7y4wkm1-4>li:before{content:"\0025cb   "}.lst-kix_insgc4ut8xxf-1>li:before{content:"\0025cb   "}.lst-kix_x2grhxcoumgd-5>li:before{content:"\0025a0   "}.lst-kix_ylu3vtdw0t29-3>li:before{content:"-  "}.lst-kix_ylu3vtdw0t29-4>li:before{content:"-  "}.lst-kix_ylu3vtdw0t29-5>li:before{content:"-  "}ul.lst-kix_84t52pnfef3b-8{list-style-type:none}ul.lst-kix_84t52pnfef3b-6{list-style-type:none}ul.lst-kix_84t52pnfef3b-7{list-style-type:none}.lst-kix_ylu3vtdw0t29-7>li:before{content:"-  "}ul.lst-kix_84t52pnfef3b-4{list-style-type:none}.lst-kix_hxj86hw44hwz-8>li:before{content:"" counter(lst-ctn-kix_hxj86hw44hwz-8,lower-roman) ". "}ul.lst-kix_84t52pnfef3b-5{list-style-type:none}.lst-kix_ylu3vtdw0t29-6>li:before{content:"-  "}.lst-kix_ylu3vtdw0t29-8>li:before{content:"-  "}ul.lst-kix_84t52pnfef3b-2{list-style-type:none}.lst-kix_hxj86hw44hwz-7>li:before{content:"" counter(lst-ctn-kix_hxj86hw44hwz-7,lower-latin) ". "}ul.lst-kix_84t52pnfef3b-3{list-style-type:none}ul.lst-kix_84t52pnfef3b-0{list-style-type:none}ul.lst-kix_84t52pnfef3b-1{list-style-type:none}.lst-kix_hxj86hw44hwz-4>li:before{content:"" counter(lst-ctn-kix_hxj86hw44hwz-4,lower-latin) ". "}.lst-kix_hxj86hw44hwz-3>li:before{content:"" counter(lst-ctn-kix_hxj86hw44hwz-3,decimal) ". "}.lst-kix_hxj86hw44hwz-5>li:before{content:"" counter(lst-ctn-kix_hxj86hw44hwz-5,lower-roman) ". "}.lst-kix_hxj86hw44hwz-2>li:before{content:"" counter(lst-ctn-kix_hxj86hw44hwz-2,lower-roman) ". "}.lst-kix_hxj86hw44hwz-6>li:before{content:"" counter(lst-ctn-kix_hxj86hw44hwz-6,decimal) ". "}.lst-kix_vd5udb8u1zxq-4>li{counter-increment:lst-ctn-kix_vd5udb8u1zxq-4}ol.lst-kix_ulfgfs8t0p10-0.start{counter-reset:lst-ctn-kix_ulfgfs8t0p10-0 0}ol.lst-kix_hxj86hw44hwz-5.start{counter-reset:lst-ctn-kix_hxj86hw44hwz-5 0}.lst-kix_o6z0gnpm11dy-8>li:before{content:"\0025a0   "}.lst-kix_o6z0gnpm11dy-7>li:before{content:"\0025cb   "}.lst-kix_o6z0gnpm11dy-5>li:before{content:"\0025a0   "}.lst-kix_hxj86hw44hwz-0>li:before{content:"" counter(lst-ctn-kix_hxj86hw44hwz-0,decimal) ". "}.lst-kix_o6z0gnpm11dy-4>li:before{content:"\0025cb   "}.lst-kix_o6z0gnpm11dy-6>li:before{content:"\0025cf   "}.lst-kix_hxj86hw44hwz-1>li:before{content:"" counter(lst-ctn-kix_hxj86hw44hwz-1,lower-latin) ". "}ul.lst-kix_6lpac386yqkw-8{list-style-type:none}ul.lst-kix_x2grhxcoumgd-3{list-style-type:none}ul.lst-kix_x2grhxcoumgd-4{list-style-type:none}ul.lst-kix_x2grhxcoumgd-5{list-style-type:none}ul.lst-kix_x2grhxcoumgd-6{list-style-type:none}ul.lst-kix_x2grhxcoumgd-7{list-style-type:none}ul.lst-kix_x2grhxcoumgd-8{list-style-type:none}.lst-kix_hxj86hw44hwz-4>li{counter-increment:lst-ctn-kix_hxj86hw44hwz-4}.lst-kix_hxj86hw44hwz-1>li{counter-increment:lst-ctn-kix_hxj86hw44hwz-1}ul.lst-kix_x2grhxcoumgd-0{list-style-type:none}ul.lst-kix_x2grhxcoumgd-1{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-4.start{counter-reset:lst-ctn-kix_vd5udb8u1zxq-4 0}ul.lst-kix_x2grhxcoumgd-2{list-style-type:none}.lst-kix_hxj86hw44hwz-2>li{counter-increment:lst-ctn-kix_hxj86hw44hwz-2}ol.lst-kix_ulfgfs8t0p10-4{list-style-type:none}ol.lst-kix_ulfgfs8t0p10-3{list-style-type:none}.lst-kix_6lpac386yqkw-0>li:before{content:"\0025cf   "}ol.lst-kix_ulfgfs8t0p10-6{list-style-type:none}ol.lst-kix_ulfgfs8t0p10-5{list-style-type:none}ol.lst-kix_ulfgfs8t0p10-0{list-style-type:none}ol.lst-kix_ulfgfs8t0p10-2{list-style-type:none}ol.lst-kix_ulfgfs8t0p10-1{list-style-type:none}ol.lst-kix_hxj86hw44hwz-2.start{counter-reset:lst-ctn-kix_hxj86hw44hwz-2 0}.lst-kix_vd5udb8u1zxq-1>li{counter-increment:lst-ctn-kix_vd5udb8u1zxq-1}.lst-kix_ulfgfs8t0p10-0>li{counter-increment:lst-ctn-kix_ulfgfs8t0p10-0}.lst-kix_3ayt6ix3e4uh-0>li:before{content:"-  "}.lst-kix_hxj86hw44hwz-3>li{counter-increment:lst-ctn-kix_hxj86hw44hwz-3}.lst-kix_6lpac386yqkw-6>li:before{content:"\0025cf   "}.lst-kix_6lpac386yqkw-8>li:before{content:"\0025a0   "}.lst-kix_vd5udb8u1zxq-6>li:before{content:"" counter(lst-ctn-kix_vd5udb8u1zxq-6,decimal) ". "}.lst-kix_3ayt6ix3e4uh-2>li:before{content:"-  "}ol.lst-kix_ulfgfs8t0p10-6.start{counter-reset:lst-ctn-kix_ulfgfs8t0p10-6 0}ul.lst-kix_3ayt6ix3e4uh-4{list-style-type:none}ul.lst-kix_3ayt6ix3e4uh-5{list-style-type:none}ul.lst-kix_3ayt6ix3e4uh-6{list-style-type:none}.lst-kix_6lpac386yqkw-2>li:before{content:"\0025a0   "}.lst-kix_6lpac386yqkw-4>li:before{content:"\0025cb   "}ul.lst-kix_3ayt6ix3e4uh-7{list-style-type:none}.lst-kix_vd5udb8u1zxq-8>li:before{content:"" counter(lst-ctn-kix_vd5udb8u1zxq-8,lower-roman) ". "}ul.lst-kix_3ayt6ix3e4uh-0{list-style-type:none}ol.lst-kix_ulfgfs8t0p10-8{list-style-type:none}ul.lst-kix_3ayt6ix3e4uh-1{list-style-type:none}ol.lst-kix_ulfgfs8t0p10-7{list-style-type:none}ul.lst-kix_3ayt6ix3e4uh-2{list-style-type:none}ul.lst-kix_3ayt6ix3e4uh-3{list-style-type:none}.lst-kix_3ayt6ix3e4uh-6>li:before{content:"-  "}.lst-kix_3ayt6ix3e4uh-4>li:before{content:"-  "}ol.lst-kix_hxj86hw44hwz-4{list-style-type:none}ol.lst-kix_hxj86hw44hwz-3{list-style-type:none}.lst-kix_ylu3vtdw0t29-2>li:before{content:"-  "}ol.lst-kix_hxj86hw44hwz-6{list-style-type:none}ol.lst-kix_hxj86hw44hwz-5{list-style-type:none}.lst-kix_6d03k7jdfpim-7>li:before{content:"\0025cb   "}.lst-kix_vvh90m5tr5ag-8>li:before{content:"\0025a0   "}ol.lst-kix_hxj86hw44hwz-8{list-style-type:none}.lst-kix_dbwn88c6y82-8>li:before{content:"\0025a0   "}ol.lst-kix_hxj86hw44hwz-7{list-style-type:none}.lst-kix_6d03k7jdfpim-5>li:before{content:"\0025a0   "}.lst-kix_vvh90m5tr5ag-6>li:before{content:"\0025cf   "}.lst-kix_dbwn88c6y82-6>li:before{content:"\0025cf   "}.lst-kix_ylu3vtdw0t29-0>li:before{content:"-  "}ol.lst-kix_vd5udb8u1zxq-2.start{counter-reset:lst-ctn-kix_vd5udb8u1zxq-2 0}ol.lst-kix_hxj86hw44hwz-1.start{counter-reset:lst-ctn-kix_hxj86hw44hwz-1 0}.lst-kix_3ayt6ix3e4uh-8>li:before{content:"-  "}.lst-kix_6d03k7jdfpim-1>li:before{content:"\0025cb   "}.lst-kix_dbwn88c6y82-2>li:before{content:"\0025a0   "}ol.lst-kix_ulfgfs8t0p10-3.start{counter-reset:lst-ctn-kix_ulfgfs8t0p10-3 0}.lst-kix_6d03k7jdfpim-3>li:before{content:"\0025cf   "}.lst-kix_dbwn88c6y82-0>li:before{content:"\0025cf   "}.lst-kix_dbwn88c6y82-4>li:before{content:"\0025cb   "}.lst-kix_8xualwd7abmn-5>li:before{content:"\0025a0   "}.lst-kix_xsdacgr1md4u-0>li:before{content:"\0025cf   "}.lst-kix_vd5udb8u1zxq-6>li{counter-increment:lst-ctn-kix_vd5udb8u1zxq-6}.lst-kix_8xualwd7abmn-7>li:before{content:"\0025cb   "}ol.lst-kix_vd5udb8u1zxq-1.start{counter-reset:lst-ctn-kix_vd5udb8u1zxq-1 0}.lst-kix_xsdacgr1md4u-2>li:before{content:"\0025a0   "}.lst-kix_vd5udb8u1zxq-0>li{counter-increment:lst-ctn-kix_vd5udb8u1zxq-0}.lst-kix_xsdacgr1md4u-6>li:before{content:"\0025cf   "}ol.lst-kix_vd5udb8u1zxq-8{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-7{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-6{list-style-type:none}.lst-kix_xsdacgr1md4u-4>li:before{content:"\0025cb   "}.lst-kix_xsdacgr1md4u-8>li:before{content:"\0025a0   "}ol.lst-kix_vd5udb8u1zxq-5{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-4{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-3{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-2{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-1{list-style-type:none}.lst-kix_ulfgfs8t0p10-5>li{counter-increment:lst-ctn-kix_ulfgfs8t0p10-5}ol.lst-kix_vd5udb8u1zxq-0{list-style-type:none}ol.lst-kix_ulfgfs8t0p10-4.start{counter-reset:lst-ctn-kix_ulfgfs8t0p10-4 0}ol.lst-kix_hxj86hw44hwz-0{list-style-type:none}ol.lst-kix_hxj86hw44hwz-2{list-style-type:none}ol.lst-kix_hxj86hw44hwz-1{list-style-type:none}.lst-kix_hxj86hw44hwz-7>li{counter-increment:lst-ctn-kix_hxj86hw44hwz-7}ol.lst-kix_vd5udb8u1zxq-0.start{counter-reset:lst-ctn-kix_vd5udb8u1zxq-0 0}ol.lst-kix_ulfgfs8t0p10-2.start{counter-reset:lst-ctn-kix_ulfgfs8t0p10-2 0}.lst-kix_vd5udb8u1zxq-7>li{counter-increment:lst-ctn-kix_vd5udb8u1zxq-7}ol.lst-kix_ulfgfs8t0p10-8.start{counter-reset:lst-ctn-kix_ulfgfs8t0p10-8 0}.lst-kix_8xualwd7abmn-3>li:before{content:"\0025cf   "}.lst-kix_8xualwd7abmn-1>li:before{content:"\0025cb   "}.lst-kix_8xualwd7abmn-2>li:before{content:"\0025a0   "}.lst-kix_8xualwd7abmn-0>li:before{content:"\0025cf   "}.lst-kix_ulfgfs8t0p10-7>li{counter-increment:lst-ctn-kix_ulfgfs8t0p10-7}ol.lst-kix_vd5udb8u1zxq-6.start{counter-reset:lst-ctn-kix_vd5udb8u1zxq-6 0}ol.lst-kix_hxj86hw44hwz-3.start{counter-reset:lst-ctn-kix_hxj86hw44hwz-3 0}.lst-kix_ca7bql3yx5nl-6>li:before{content:"\0025cf   "}.lst-kix_ca7bql3yx5nl-7>li:before{content:"\0025cb   "}.lst-kix_84t52pnfef3b-0>li:before{content:"\0025cf   "}.lst-kix_84t52pnfef3b-1>li:before{content:"\0025cb   "}.lst-kix_vd5udb8u1zxq-5>li{counter-increment:lst-ctn-kix_vd5udb8u1zxq-5}ol.lst-kix_hxj86hw44hwz-4.start{counter-reset:lst-ctn-kix_hxj86hw44hwz-4 0}.lst-kix_ca7bql3yx5nl-3>li:before{content:"\0025cf   "}.lst-kix_84t52pnfef3b-4>li:before{content:"\0025cb   "}ol.lst-kix_ulfgfs8t0p10-7.start{counter-reset:lst-ctn-kix_ulfgfs8t0p10-7 0}.lst-kix_ulfgfs8t0p10-8>li:before{content:"" counter(lst-ctn-kix_ulfgfs8t0p10-8,lower-roman) ". "}.lst-kix_ca7bql3yx5nl-4>li:before{content:"\0025cb   "}.lst-kix_ca7bql3yx5nl-5>li:before{content:"\0025a0   "}.lst-kix_84t52pnfef3b-2>li:before{content:"\0025a0   "}.lst-kix_84t52pnfef3b-3>li:before{content:"\0025cf   "}.lst-kix_ulfgfs8t0p10-3>li:before{content:"" counter(lst-ctn-kix_ulfgfs8t0p10-3,decimal) ". "}.lst-kix_ulfgfs8t0p10-4>li:before{content:"" counter(lst-ctn-kix_ulfgfs8t0p10-4,lower-latin) ". "}.lst-kix_ulfgfs8t0p10-3>li{counter-increment:lst-ctn-kix_ulfgfs8t0p10-3}ul.lst-kix_3ayt6ix3e4uh-8{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-5.start{counter-reset:lst-ctn-kix_vd5udb8u1zxq-5 0}.lst-kix_ca7bql3yx5nl-2>li:before{content:"\0025a0   "}.lst-kix_ulfgfs8t0p10-7>li:before{content:"" counter(lst-ctn-kix_ulfgfs8t0p10-7,lower-latin) ". "}.lst-kix_ca7bql3yx5nl-0>li:before{content:"\0025cf   "}.lst-kix_ca7bql3yx5nl-1>li:before{content:"\0025cb   "}.lst-kix_ulfgfs8t0p10-5>li:before{content:"" counter(lst-ctn-kix_ulfgfs8t0p10-5,lower-roman) ". "}.lst-kix_ulfgfs8t0p10-6>li:before{content:"" counter(lst-ctn-kix_ulfgfs8t0p10-6,decimal) ". "}.lst-kix_vd5udb8u1zxq-5>li:before{content:"" counter(lst-ctn-kix_vd5udb8u1zxq-5,lower-roman) ". "}.lst-kix_vd5udb8u1zxq-4>li:before{content:"" counter(lst-ctn-kix_vd5udb8u1zxq-4,lower-latin) ". "}.lst-kix_vd5udb8u1zxq-3>li:before{content:"" counter(lst-ctn-kix_vd5udb8u1zxq-3,decimal) ". "}.lst-kix_ulfgfs8t0p10-0>li:before{content:"" counter(lst-ctn-kix_ulfgfs8t0p10-0,decimal) ". "}.lst-kix_vd5udb8u1zxq-0>li:before{content:"" counter(lst-ctn-kix_vd5udb8u1zxq-0,decimal) ". "}.lst-kix_vd5udb8u1zxq-2>li:before{content:"" counter(lst-ctn-kix_vd5udb8u1zxq-2,lower-roman) ". "}.lst-kix_ulfgfs8t0p10-1>li:before{content:"" counter(lst-ctn-kix_ulfgfs8t0p10-1,lower-latin) ". "}.lst-kix_ulfgfs8t0p10-2>li:before{content:"" counter(lst-ctn-kix_ulfgfs8t0p10-2,lower-roman) ". "}.lst-kix_vd5udb8u1zxq-1>li:before{content:"" counter(lst-ctn-kix_vd5udb8u1zxq-1,lower-latin) ". "}.lst-kix_84t52pnfef3b-8>li:before{content:"\0025a0   "}.lst-kix_84t52pnfef3b-5>li:before{content:"\0025a0   "}ol.lst-kix_ulfgfs8t0p10-1.start{counter-reset:lst-ctn-kix_ulfgfs8t0p10-1 0}.lst-kix_ca7bql3yx5nl-8>li:before{content:"\0025a0   "}.lst-kix_84t52pnfef3b-6>li:before{content:"\0025cf   "}.lst-kix_84t52pnfef3b-7>li:before{content:"\0025cb   "}.lst-kix_vd5udb8u1zxq-2>li{counter-increment:lst-ctn-kix_vd5udb8u1zxq-2}ul.lst-kix_vvh90m5tr5ag-0{list-style-type:none}ul.lst-kix_vvh90m5tr5ag-2{list-style-type:none}ul.lst-kix_vvh90m5tr5ag-1{list-style-type:none}ul.lst-kix_vvh90m5tr5ag-4{list-style-type:none}ol.lst-kix_vd5udb8u1zxq-7.start{counter-reset:lst-ctn-kix_vd5udb8u1zxq-7 0}ul.lst-kix_vvh90m5tr5ag-3{list-style-type:none}ul.lst-kix_vvh90m5tr5ag-6{list-style-type:none}ul.lst-kix_vvh90m5tr5ag-5{list-style-type:none}ul.lst-kix_vvh90m5tr5ag-8{list-style-type:none}ul.lst-kix_vvh90m5tr5ag-7{list-style-type:none}.lst-kix_6lpac386yqkw-1>li:before{content:"\0025cb   "}ul.lst-kix_insgc4ut8xxf-0{list-style-type:none}ul.lst-kix_insgc4ut8xxf-1{list-style-type:none}ul.lst-kix_insgc4ut8xxf-4{list-style-type:none}ul.lst-kix_insgc4ut8xxf-5{list-style-type:none}ul.lst-kix_insgc4ut8xxf-2{list-style-type:none}ul.lst-kix_insgc4ut8xxf-3{list-style-type:none}ul.lst-kix_insgc4ut8xxf-8{list-style-type:none}ul.lst-kix_insgc4ut8xxf-6{list-style-type:none}ul.lst-kix_insgc4ut8xxf-7{list-style-type:none}.lst-kix_6lpac386yqkw-7>li:before{content:"\0025cb   "}ul.lst-kix_ylu3vtdw0t29-8{list-style-type:none}.lst-kix_ulfgfs8t0p10-1>li{counter-increment:lst-ctn-kix_ulfgfs8t0p10-1}.lst-kix_6lpac386yqkw-5>li:before{content:"\0025a0   "}ul.lst-kix_ylu3vtdw0t29-5{list-style-type:none}ul.lst-kix_ylu3vtdw0t29-4{list-style-type:none}.lst-kix_3ayt6ix3e4uh-1>li:before{content:"-  "}ul.lst-kix_ylu3vtdw0t29-7{list-style-type:none}.lst-kix_hxj86hw44hwz-0>li{counter-increment:lst-ctn-kix_hxj86hw44hwz-0}.lst-kix_vd5udb8u1zxq-7>li:before{content:"" counter(lst-ctn-kix_vd5udb8u1zxq-7,lower-latin) ". "}ul.lst-kix_ylu3vtdw0t29-6{list-style-type:none}.lst-kix_6lpac386yqkw-3>li:before{content:"\0025cf   "}.lst-kix_3ayt6ix3e4uh-7>li:before{content:"-  "}ul.lst-kix_6d03k7jdfpim-1{list-style-type:none}ul.lst-kix_6d03k7jdfpim-0{list-style-type:none}.lst-kix_3ayt6ix3e4uh-5>li:before{content:"-  "}ul.lst-kix_6d03k7jdfpim-3{list-style-type:none}ul.lst-kix_6d03k7jdfpim-2{list-style-type:none}ul.lst-kix_ylu3vtdw0t29-1{list-style-type:none}ul.lst-kix_6d03k7jdfpim-5{list-style-type:none}ul.lst-kix_ylu3vtdw0t29-0{list-style-type:none}ul.lst-kix_6d03k7jdfpim-4{list-style-type:none}ul.lst-kix_ylu3vtdw0t29-3{list-style-type:none}ul.lst-kix_6d03k7jdfpim-7{list-style-type:none}ul.lst-kix_ylu3vtdw0t29-2{list-style-type:none}ul.lst-kix_6d03k7jdfpim-6{list-style-type:none}ul.lst-kix_6d03k7jdfpim-8{list-style-type:none}.lst-kix_3ayt6ix3e4uh-3>li:before{content:"-  "}ul.lst-kix_o6z0gnpm11dy-1{list-style-type:none}ul.lst-kix_o6z0gnpm11dy-2{list-style-type:none}ul.lst-kix_o6z0gnpm11dy-0{list-style-type:none}.lst-kix_ylu3vtdw0t29-1>li:before{content:"-  "}.lst-kix_6d03k7jdfpim-8>li:before{content:"\0025a0   "}.lst-kix_ulfgfs8t0p10-2>li{counter-increment:lst-ctn-kix_ulfgfs8t0p10-2}.lst-kix_dbwn88c6y82-7>li:before{content:"\0025cb   "}ul.lst-kix_o6z0gnpm11dy-7{list-style-type:none}.lst-kix_vvh90m5tr5ag-5>li:before{content:"\0025a0   "}.lst-kix_vvh90m5tr5ag-7>li:before{content:"\0025cb   "}ul.lst-kix_o6z0gnpm11dy-8{list-style-type:none}ul.lst-kix_8xualwd7abmn-6{list-style-type:none}ul.lst-kix_o6z0gnpm11dy-5{list-style-type:none}.lst-kix_hxj86hw44hwz-5>li{counter-increment:lst-ctn-kix_hxj86hw44hwz-5}ul.lst-kix_8xualwd7abmn-5{list-style-type:none}ul.lst-kix_o6z0gnpm11dy-6{list-style-type:none}ul.lst-kix_8xualwd7abmn-8{list-style-type:none}ul.lst-kix_o6z0gnpm11dy-3{list-style-type:none}.lst-kix_6d03k7jdfpim-6>li:before{content:"\0025cf   "}ul.lst-kix_8xualwd7abmn-7{list-style-type:none}ul.lst-kix_o6z0gnpm11dy-4{list-style-type:none}ul.lst-kix_8xualwd7abmn-2{list-style-type:none}ul.lst-kix_8xualwd7abmn-1{list-style-type:none}.lst-kix_dbwn88c6y82-3>li:before{content:"\0025cf   "}ul.lst-kix_8xualwd7abmn-4{list-style-type:none}ul.lst-kix_8xualwd7abmn-3{list-style-type:none}.lst-kix_dbwn88c6y82-1>li:before{content:"\0025cb   "}.lst-kix_dbwn88c6y82-5>li:before{content:"\0025a0   "}ul.lst-kix_8xualwd7abmn-0{list-style-type:none}.lst-kix_6d03k7jdfpim-0>li:before{content:"\0025cf   "}.lst-kix_6d03k7jdfpim-4>li:before{content:"\0025cb   "}ol.lst-kix_hxj86hw44hwz-7.start{counter-reset:lst-ctn-kix_hxj86hw44hwz-7 0}.lst-kix_6d03k7jdfpim-2>li:before{content:"\0025a0   "}.lst-kix_8xualwd7abmn-4>li:before{content:"\0025cb   "}.lst-kix_8xualwd7abmn-6>li:before{content:"\0025cf   "}.lst-kix_8xualwd7abmn-8>li:before{content:"\0025a0   "}.lst-kix_xsdacgr1md4u-3>li:before{content:"\0025cf   "}.lst-kix_vd5udb8u1zxq-3>li{counter-increment:lst-ctn-kix_vd5udb8u1zxq-3}.lst-kix_xsdacgr1md4u-1>li:before{content:"\0025cb   "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ol.lst-kix_hxj86hw44hwz-8.start{counter-reset:lst-ctn-kix_hxj86hw44hwz-8 0}.lst-kix_xsdacgr1md4u-7>li:before{content:"\0025cb   "}.lst-kix_ulfgfs8t0p10-8>li{counter-increment:lst-ctn-kix_ulfgfs8t0p10-8}.lst-kix_xsdacgr1md4u-5>li:before{content:"\0025a0   "}ol{margin:0;padding:0}table td,table th{padding:0}.c44{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f8f8f8;border-left-style:solid;border-bottom-width:0pt;width:461.2pt;border-top-color:#000000;border-bottom-style:solid}.c17{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f8f8f8;border-left-style:solid;border-bottom-width:0pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c2{margin-left:108pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c27{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c33{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c14{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c45{padding-top:12pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c43{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c39{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c18{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c1{padding-top:14pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c42{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial"}.c22{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c50{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c51{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial"}.c20{background-color:#f8f8f8;font-family:"Consolas";font-style:italic;color:#999988;font-weight:400}.c26{background-color:#f8f8f8;font-family:"Fira Code";font-style:italic;color:#999988;font-weight:400}.c21{background-color:#f8f8f8;font-family:"Consolas";color:#445588;font-weight:700}.c8{background-color:#f8f8f8;font-family:"Consolas";color:#333333;font-weight:400}.c31{background-color:#f8f8f8;font-family:"Consolas";color:#0086b3;font-weight:400}.c23{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c28{background-color:#f8f8f8;font-family:"Consolas";color:#008080;font-weight:400}.c29{background-color:#f8f8f8;font-family:"Fira Code";color:#dd1144;font-weight:400}.c35{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c6{border-spacing:0;border-collapse:collapse;margin-right:auto}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c37{margin-left:6.8pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c34{background-color:#f8f8f8;font-family:"Consolas";color:#dd1144;font-weight:400}.c4{background-color:#f8f8f8;font-family:"Consolas";color:#999999;font-weight:700}.c12{background-color:#f8f8f8;font-family:"Consolas";color:#333333;font-weight:700}.c40{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c54{background-color:#f8f8f8;font-family:"Fira Code";color:#333333;font-weight:700}.c9{background-color:#f8f8f8;font-family:"Consolas";color:#990000;font-weight:700}.c38{background-color:#f8f8f8;font-family:"Fira Code";color:#333333;font-weight:400}.c53{color:#000000;font-weight:700;font-family:"Arial"}.c48{color:#000000;font-weight:400;font-family:"Fira Code"}.c15{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c13{color:#188038;font-weight:400;font-family:"Roboto Mono"}.c32{color:#666666;font-weight:400;font-family:"Arial"}.c24{margin-left:72pt;padding-left:0pt}.c19{padding:0;margin:0}.c41{color:inherit;text-decoration:inherit}.c10{border:1px solid black;margin:5px}.c47{margin-left:36pt;padding-left:0pt}.c25{height:12pt}.c46{font-size:10pt}.c30{font-style:italic}.c49{margin-left:36pt}.c11{height:11pt}.c16{height:0pt}.c36{height:20pt}.c52{font-size:26pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c15 doc-content"><p class="c43 title" id="h.rkdy1td2epxp"><span class="c50 c52">&#128649; Metro</span></p><p class="c22"><span><br></span><span class="c23 c53">NOVEMBER 6th, 2025 NOTE</span></p><p class="c22"><span class="c3">This document is the original Metro design doc. After discussing with contributors and getting permission from commenters, we&rsquo;ve made this document </span><span class="c40"><a class="c41" href="https://docs.google.com/document/d/e/2PACX-1vRGRcBBLmvgaAWpnC8IyWlvGWCemKBpklIkJB8aMxlFOqm7T-tHW7BzP1Qe9i9AVuQyn_OiBf-lFPnR/pub">publicly viewable</a></span>.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>It was mostly written in December 2024 and shared with a group of people active (most listed </span><span class="c40"><a class="c41" href="https://zacsweers.github.io/metro/latest/%23acknowledgements">here</a></span><span class="c3">) in the DI space for input, feedback, and advice. Below is the document as it was by roughly end of January 2025. Most of the final docs moved to Metro&rsquo;s documentation site.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">All comment threads have been marked &ldquo;unresolved&rdquo; so they&rsquo;re visible in the html export, which will be available statically on the Metro doc site.</span></p><p class="c5"><span class="c3"></span></p><p class="c5"><span class="c3"></span></p><hr><p class="c5"><span class="c3"></span></p><p class="c5"><span class="c3"><br></span></p><p class="c22"><span class="c51 c46 c30">Author: Zac Sweers</span></p><p class="c22"><span class="c46 c30">Repo: </span><span class="c40 c46 c30"><a class="c41" href="https://www.google.com/url?q=https://github.com/ZacSweers/metro&amp;sa=D&amp;source=editors&amp;ust=1762461866417562&amp;usg=AOvVaw2PQTdPZz7-CatV4hlQ1pgz">https://github.com/ZacSweers/metro</a></span></p><p class="c22"><span class="c30 c46">Formerly known as Lattice</span></p><h1 class="c27" id="h.ojbt4rj6hgr8"><span class="c33">Introduction</span></h1><p class="c22"><span>Metro is a compile-time dependency injection framework that draws heavy inspiration from </span><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/google/dagger&amp;sa=D&amp;source=editors&amp;ust=1762461866417960&amp;usg=AOvVaw2d4f_z074eH_c48UrCsI2u">Dagger</a></span><span>, </span><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/square/anvil&amp;sa=D&amp;source=editors&amp;ust=1762461866418079&amp;usg=AOvVaw0U7KlGcZyHcbC4Kw5vTTRA">Anvil</a></span><span>, and </span><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/evant/kotlin-inject&amp;sa=D&amp;source=editors&amp;ust=1762461866418231&amp;usg=AOvVaw16aLIAKLFhuW-cpfGuH2VA">Kotlin-Inject</a></span><span class="c3">&nbsp;(KI). It seeks to unify their best features under one, cohesive solution while adding a few new features and benefits.</span></p><h3 class="c39" id="h.ut2xc81hgamo"><span>Why another DI framework?</span><sup><a href="#cmnt1" id="cmnt_ref1">[a]</a></sup><sup><a href="#cmnt2" id="cmnt_ref2">[b]</a></sup><sup><a href="#cmnt3" id="cmnt_ref3">[c]</a></sup><sup><a href="#cmnt4" id="cmnt_ref4">[d]</a></sup><sup><a href="#cmnt5" id="cmnt_ref5">[e]</a></sup></h3><p class="c22"><span>It</span><span class="c3">&rsquo;s felt for some time like the Kotlin community has been waiting for a library that unifies the best of Dagger, multiplatform, Anvil aggregation, compiler plugin, and Kotlin-first. Different solutions exist for parts of these, but there&rsquo;s not yet been a cohesive, unified solution that checks all these boxes, leaves behind some of these tools&rsquo; limitations, and embraces newer features that native compiler plugins offer.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">In short, Metro stands on the shoulders of giants. It doesn&rsquo;t seek to reinvent the wheel and tries to build on top of what existing solutions do well. The goal is a solution that unifies their best ideas.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c30">I&rsquo;m aware of the </span><span class="c40 c30"><a class="c41" href="https://www.google.com/url?q=https://xkcd.com/927/&amp;sa=D&amp;source=editors&amp;ust=1762461866419504&amp;usg=AOvVaw14Mz4dNz7zE4sC34J3a4sf">XKCD comic</a></span><span class="c42 c30">&nbsp;&#128578;, I think Metro offers a compelling feature set with interop hooks that make it easy to integrate with an existing codebase.</span></p><sup><a href="#cmnt6" id="cmnt_ref6">[f]</a></sup><p class="c5"><span class="c3"></span></p><hr><p class="c5"><span class="c3"></span></p><h1 class="c27" id="h.bzdxwhd8bk44"><span class="c33">Overview</span></h1><h3 class="c39" id="h.o7wvfduawv4t"><span class="c14">Features</span></h3><ul class="c19 lst-kix_xsdacgr1md4u-0 start"><li class="c7 li-bullet-0"><span class="c3">Familiar semantics</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">Metro builds on top of established patterns from existing DI frameworks with familiar semantics like constructor injection, providers, multibindings, scopes, assisted injection, and intrinsics like Provider/Lazy.</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-0"><li class="c7 li-bullet-0"><span class="c3">Compile-time validation</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">Like Dagger and KI, Metro validates your dependency graph at compile-time.</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-0"><li class="c7 li-bullet-0"><span class="c3">Compile-time FIR+IR code gen</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-1 start"><li class="c22 c24 li-bullet-0"><span>Metro is implemented entirely as a </span><span>Kotlin compiler plugin</span><sup><a href="#cmnt7" id="cmnt_ref7">[g]</a></sup><sup><a href="#cmnt8" id="cmnt_ref8">[h]</a></sup><span class="c3">, primarily using FIR for error reporting and both FIR and IR for code gen. This affords significant build performance and wins compared to Dagger and KAPT/KSP in two ways:</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-2 start"><li class="c2 li-bullet-0"><span class="c3">It avoids extra Kotlin compiler (frontend) invocations to analyze sources and generate new sources.</span></li><li class="c2 li-bullet-0"><span class="c3">It generates new code to FIR/IR directly, allowing it to be lowered directly into target platforms</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-1"><li class="c22 c24 li-bullet-0"><span class="c3">FIR/IR generation allows Metro to generate code directly into existing classes, which in turn allows it to do certain things that source-generation cannot. This includes:</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-2 start"><li class="c2 li-bullet-0"><span>Private </span><span class="c13">@Provides</span><span class="c3">&nbsp;declarations.</span></li><li class="c2 li-bullet-0"><span class="c3">Injection of private constructors*, properties, and functions.</span></li><li class="c2 li-bullet-0"><span>Copying + reuse of default value expressions for optional dependencies, even if they reference private APIs within the source class.</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-0"><li class="c7 li-bullet-0"><span class="c3">Dagger-esque code gen and runtime</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">Metro&rsquo;s generated code is similar to Dagger: lean, limited duplication, and practical.</span></li><li class="c22 c24 li-bullet-0"><span>Metro&rsquo;s runtime is similar to Dagger. This includes patterns like </span><span class="c13">DoubleCheck</span><span class="c3">, heavy use of factories, and an assumption that this is going to run in a large/modularized codebase.</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-0"><li class="c7 li-bullet-0"><span class="c3">Kotlin-Inject-esque API</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">Metro&rsquo;s user-facing API is similar to kotlin-inject: focused on simplicity and leaning into kotlin-language features.</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-2 start"><li class="c2 li-bullet-0"><span class="c3">Top-level function injection</span></li><li class="c2 li-bullet-0"><span class="c3">Providers live in graph interfaces or supertypes</span></li><li class="c2 li-bullet-0"><span class="c3">Native support for optional bindings via default parameter values</span></li><li class="c2 li-bullet-0"><span>Use of Kotlin&rsquo;s native </span><span class="c13">Lazy</span><span>&nbsp;type for lazy injections</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-0"><li class="c7 li-bullet-0"><span>Anvil-esque aggregation via </span><span class="c13">@ContributesTo</span><span>/</span><span class="c13">@ContributesBinding/etc</span><span>.</span></li><li class="c7 li-bullet-0"><span class="c3">Multiplatform</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">Metro is multiplatform and supports most major Kotlin multiplatform targets.</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-0"><li class="c7 li-bullet-0"><span class="c3">IDE Integration</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">Most errors are reported in FIR, which should (eventually) be visible in the K2 IDE plugin as well.</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-0"><li class="c7 li-bullet-0"><span class="c3">Compelling interop</span></li></ul><ul class="c19 lst-kix_xsdacgr1md4u-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">Metro supports component-level interop with Dagger and kotlin-inject. This means that Metro graphs can depend on Dagger and kotlin-inject components.</span></li><li class="c22 c24 li-bullet-0"><span class="c3">Metro supports defining user-defined alternatives for common annotations in addition to its first-party options. This allows easier introduction to codebases using annotations from existing DI frameworks.</span></li></ul><h3 class="c39" id="h.pim4kytl6rzg"><span class="c14">Differences</span></h3><h4 class="c1" id="h.yt1yx285ljk9"><span>&hellip;from Dagger</span><sup><a href="#cmnt9" id="cmnt_ref9">[i]</a></sup><sup><a href="#cmnt10" id="cmnt_ref10">[j]</a></sup><sup><a href="#cmnt11" id="cmnt_ref11">[k]</a></sup><sup><a href="#cmnt12" id="cmnt_ref12">[l]</a></sup><sup><a href="#cmnt13" id="cmnt_ref13">[m]</a></sup></h4><ul class="c19 lst-kix_dbwn88c6y82-0 start"><li class="c7 li-bullet-0"><span>There is no </span><span class="c13">@Module</span><span class="c3">. All providers run through graphs and their supertypes.</span></li><li class="c7 li-bullet-0"><span class="c3">There is no Producers support.</span></li><li class="c7 li-bullet-0"><span class="c3">There is no Hilt support, though some features are similar in the same way that Anvil&rsquo;s features are similar.</span></li><li class="c7 li-bullet-0"><span>There is no </span><span class="c13">@Reusable</span><span class="c3">.</span></li><li class="c7 li-bullet-0"><span>There is no </span><span class="c13">@BindsOptionalOf</span><span class="c3">.</span></li><li class="c7 li-bullet-0"><span>There is no </span><span class="c13">@Subcomponent</span><span class="c3">.</span></li><li class="c7 li-bullet-0"><span class="c3">Metro can inject private properties and functions.</span></li><li class="c7 li-bullet-0"><span>There is no </span><span class="c13">@BindsInstance</span><span>. Use </span><span class="c13">@Provides</span><span>&nbsp;on </span><span class="c13">@DependencyGraph.Factory</span><span>&nbsp;function parameters instead</span></li></ul><h4 class="c1" id="h.oichhjetoksm"><span class="c18">&hellip;from Kotlin-Inject</span></h4><ul class="c19 lst-kix_ca7bql3yx5nl-0 start"><li class="c7 li-bullet-0"><span class="c3">typealiases are not treated as implicit qualifiers.</span></li><li class="c7 li-bullet-0"><span>Dependency graph classes cannot have primary constructors, their parameters must be defined as </span><span class="c13">@Provides</span><span>&nbsp;or graph parameters on a </span><span class="c13">@DependencyGraph.Factory</span><span>&nbsp;function like Dagger.</span></li><li class="c7 li-bullet-0"><span>Higher order functions cannot be used. Instead, use </span><span class="c13">Provider</span><span>&nbsp;and declared </span><span class="c13">@AssistedFactory</span><span class="c3">-annotated types.</span></li><li class="c7 li-bullet-0"><span>No need for use-site targets for most annotations.</span><sup><a href="#cmnt14" id="cmnt_ref14">[n]</a></sup><sup><a href="#cmnt15" id="cmnt_ref15">[o]</a></sup></li><li class="c7 li-bullet-0"><span>No need for </span><span class="c13">@get:Provides Impl.bind: Type get() = this</span><span>&nbsp;to achieve type bindings. See the docs on </span><span class="c13">@Provides</span><span class="c3">.</span></li><li class="c7 li-bullet-0"><span>Metro can inject private properties and functions.</span></li></ul><h4 class="c1" id="h.vi8q8xpz4uqf"><span class="c18">&hellip;from Anvil</span></h4><ul class="c19 lst-kix_dbwn88c6y82-0"><li class="c7 li-bullet-0"><span>There is no </span><span class="c13">rank</span><span class="c3">.</span></li><li class="c7 li-bullet-0"><span class="c13">@ContributesBinding</span><span class="c3">&nbsp;requires an explicit bound type.</span></li></ul><ul class="c19 lst-kix_dbwn88c6y82-1 start"><li class="c22 c24 li-bullet-0"><span>This is necessary to support generic bound types.</span></li></ul><h4 class="c1" id="h.huhm53277t7l"><span class="c18">&hellip;from kotlin-inject-anvil</span></h4><ul class="c19 lst-kix_dbwn88c6y82-0"><li class="c7 li-bullet-0"><span>There is n</span><span>o need for </span><span class="c13">@CreateComponent</span><span>&nbsp;or </span><span class="c13">expect fun createComponent()</span><span class="c3">&nbsp;functions.</span></li><li class="c7 li-bullet-0"><span class="c13">@ContributesBinding</span><span class="c3">&nbsp;requires an explicit bound type.</span></li></ul><ul class="c19 lst-kix_dbwn88c6y82-1 start"><li class="c22 c24 li-bullet-0"><span>This is necessary to support generic bound types.</span></li></ul><p class="c5"><span class="c3"></span></p><hr><p class="c5"><span class="c3"></span></p><h1 class="c27" id="h.ias3nxkf17x1"><span class="c33">Installation</span></h1><p class="c22"><span>Metro is primarily applied via its companion </span><span>Gradle plugin</span><sup><a href="#cmnt16" id="cmnt_ref16">[p]</a></sup><sup><a href="#cmnt17" id="cmnt_ref17">[q]</a></sup><sup><a href="#cmnt18" id="cmnt_ref18">[r]</a></sup><sup><a href="#cmnt19" id="cmnt_ref19">[s]</a></sup><sup><a href="#cmnt20" id="cmnt_ref20">[t]</a></sup><span class="c3">.</span></p><p class="c5"><span class="c3"></span></p><table class="c37"><tr class="c16"><td class="c44" colspan="1" rowspan="1"><p class="c35"><span class="c8">plugins {<br> &nbsp;kotlin(</span><span class="c34">&quot;multiplatform&quot;</span><span class="c8">) </span><span class="c20">// or jvm, android, etc</span><span class="c8"><br> &nbsp;id(</span><span class="c34">&quot;dev.zacsweers.metro&quot;</span><span class="c8">)<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">&hellip;and that&rsquo;s it! This will add metro&rsquo;s runtime dependencies and do all the necessary compiler plugin wiring.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>If applying in other build systems, apply it however that build system conventionally applies Kotlin compiler plugins. For example with </span><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/bazelbuild/rules_kotlin?tab%3Dreadme-ov-file%23kotlin-compiler-plugins&amp;sa=D&amp;source=editors&amp;ust=1762461866426962&amp;usg=AOvVaw3T0UpfnL2xrk2y5YqTIY4X">Bazel</a></span><span class="c3">:</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c38">load(</span><span class="c29">&quot;@rules_kotlin//kotlin:core.bzl&quot;</span><span class="c38">, </span><span class="c29">&quot;kt_compiler_plugin&quot;</span><span class="c38">)<br>load(</span><span class="c29">&quot;@rules_kotlin//kotlin:jvm.bzl&quot;</span><span class="c38">, </span><span class="c29">&quot;kt_jvm_library&quot;</span><span class="c38">)<br><br>kt_compiler_plugin(<br> &nbsp; &nbsp;name = </span><span class="c29">&quot;metro_plugin&quot;</span><span class="c38">,<br> &nbsp; &nbsp;compile_phase = </span><span class="c54">True</span><span class="c38">,<br> &nbsp; &nbsp;id = </span><span class="c29">&quot;dev.zacsweers.metro.compiler&quot;</span><span class="c38">,<br> &nbsp; &nbsp;options = {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c29">&quot;enabled&quot;</span><span class="c38">: </span><span class="c29">&quot;true&quot;</span><span class="c38">,<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c29">&quot;debug&quot;</span><span class="c38">: </span><span class="c29">&quot;false&quot;</span><span class="c38">,<br> &nbsp; &nbsp;},<br> &nbsp; &nbsp;deps = [<br> &nbsp; &nbsp; &nbsp; &nbsp;&#8203;&#8203;</span><span class="c29">&quot;@maven//:dev_zacsweers_metro_compiler&quot;</span><span class="c38">,<br> &nbsp; &nbsp;],<br>)<br><br>kt_jvm_library(<br> &nbsp; &nbsp;name = </span><span class="c29">&quot;sample&quot;</span><span class="c38">,<br> &nbsp; &nbsp;</span><span class="c26"># The SampleGraph class is annotated with @DependencyGraph</span><span class="c38"><br> &nbsp; &nbsp;srcs = [</span><span class="c29">&quot;SampleGraph.kt&quot;</span><span class="c38">],<br> &nbsp; &nbsp;plugins = [<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c29">&quot;:metro_plugin&quot;</span><span class="c38">,<br> &nbsp; &nbsp;],<br> &nbsp; &nbsp;deps = [<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c29">&quot;@maven//:dev_zacsweers_metro_runtime_jvm&quot;</span><span class="c38">,<br> &nbsp; &nbsp;],<br>)</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><hr><p class="c5"><span class="c3"></span></p><h1 class="c27" id="h.xfkk71qo5244"><span class="c33">Design</span></h1><h3 class="c39" id="h.h74j607nhd1r"><span class="c14">Dependency Graphs</span></h3><p class="c22"><span>The primary entry points in Metro are </span><span class="c30">dependency graphs</span><span>. These are interfaces annotated with </span><span class="c13">@</span><span class="c13">DependencyGraph</span><sup><a href="#cmnt21" id="cmnt_ref21">[u]</a></sup><sup><a href="#cmnt22" id="cmnt_ref22">[v]</a></sup><sup><a href="#cmnt23" id="cmnt_ref23">[w]</a></sup><span>&nbsp;and created with </span><span class="c13">@DependencyGraph.Factory</span><span>&nbsp;interfaces. Graphs expose types from the object graph via accessor </span><span>properties or functions</span><sup><a href="#cmnt24" id="cmnt_ref24">[x]</a></sup><sup><a href="#cmnt25" id="cmnt_ref25">[y]</a></sup><sup><a href="#cmnt26" id="cmnt_ref26">[z]</a></sup><sup><a href="#cmnt27" id="cmnt_ref27">[aa]</a></sup><sup><a href="#cmnt28" id="cmnt_ref28">[ab]</a></sup><sup><a href="#cmnt29" id="cmnt_ref29">[ac]</a></sup><sup><a href="#cmnt30" id="cmnt_ref30">[ad]</a></sup><sup><a href="#cmnt31" id="cmnt_ref31">[ae]</a></sup><sup><a href="#cmnt32" id="cmnt_ref32">[af]</a></sup><span class="c3">.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>TIP: These are analogous to </span><span class="c30">components</span><span>&nbsp;and </span><span class="c13">@Component</span><span>/</span><span class="c13">@Component.Factory</span><span class="c3">&nbsp;in Dagger and kotlin-inject.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>TIP: &ldquo;Accessors&rdquo; in Metro are synonymous with Dagger&rsquo;s TODO link </span><span class="c30">provision methods</span><span class="c3">.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>Accessors and </span><span>member injections</span><sup><a href="#cmnt33" id="cmnt_ref33">[ag]</a></sup><sup><a href="#cmnt34" id="cmnt_ref34">[ah]</a></sup><sup><a href="#cmnt35" id="cmnt_ref35">[ai]</a></sup><sup><a href="#cmnt36" id="cmnt_ref36">[aj]</a></sup><span>&nbsp;act as roots, from which the dependency graph is resolved. Dependencies can be provided via conventional </span><span class="c13">@Provides</span><span class="c3">&nbsp;functions in graphs or their supertypes, constructor-injected classes, or accessed from graph dependencies.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br><br> &nbsp;</span><span class="c4">@Provides</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideMessage</span><sup><a href="#cmnt37" id="cmnt_ref37">[ak]</a></sup><sup><a href="#cmnt38" id="cmnt_ref38">[al]</a></sup><sup><a href="#cmnt39" id="cmnt_ref39">[am]</a></sup><sup><a href="#cmnt40" id="cmnt_ref40">[an]</a></sup><sup><a href="#cmnt41" id="cmnt_ref41">[ao]</a></sup><span class="c8">(): String = </span><span class="c34">&quot;Hello, world!&quot;</span><sup><a href="#cmnt42" id="cmnt_ref42">[ap]</a></sup><sup><a href="#cmnt43" id="cmnt_ref43">[aq]</a></sup><sup><a href="#cmnt44" id="cmnt_ref44">[ar]</a></sup><sup><a href="#cmnt45" id="cmnt_ref45">[as]</a></sup><sup><a href="#cmnt46" id="cmnt_ref46">[at]</a></sup><span class="c8 c23"><br>}</span></p></td></tr></table><p class="c22"><span class="c30">Note the </span><span class="c13 c30">@Provides</span><span class="c30">&nbsp;function must define an explicit return type</span><sup><a href="#cmnt47" id="cmnt_ref47">[au]</a></sup><sup><a href="#cmnt48" id="cmnt_ref48">[av]</a></sup><span class="c30">.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>Simple graphs like this can be created via the </span><span class="c13">createGraph()</span><span class="c3">&nbsp;intrinsic.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c12">val</span><span class="c8">&nbsp;graph = </span><span class="c8">create</span><sup><a href="#cmnt49" id="cmnt_ref49">[aw]</a></sup><sup><a href="#cmnt50" id="cmnt_ref50">[ax]</a></sup><span class="c8">Graph&lt;AppGraph&gt;()</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Graphs are relatively cheap and should be used freely.</span></p><h4 class="c1" id="h.44m33tfxrevr"><span class="c18">Inputs</span></h4><p class="c22"><span>Instance parameters and graph dependencies can be provided via a </span><span class="c13">@DependencyGraph.Factory</span><span class="c3">&nbsp;interface that returns the target graph.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br><br> &nbsp;</span><span class="c4">@DependencyGraph</span><span class="c8">.Factory<br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;interface Factory {<br> &nbsp; &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">create</span><span class="c8">(</span><span class="c4">@Provides</span><span class="c8">&nbsp;message: </span><span class="c21">String</span><span class="c8">): AppGraph<br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br><br> &nbsp;</span><span class="c4">@DependencyGraph</span><span class="c8">.Factory<br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;interface Factory {<br> &nbsp; &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">create</span><sup><a href="#cmnt51" id="cmnt_ref51">[ay]</a></sup><sup><a href="#cmnt52" id="cmnt_ref52">[az]</a></sup><sup><a href="#cmnt53" id="cmnt_ref53">[ba]</a></sup><sup><a href="#cmnt54" id="cmnt_ref54">[bb]</a></sup><sup><a href="#cmnt55" id="cmnt_ref55">[bc]</a></sup><sup><a href="#cmnt56" id="cmnt_ref56">[bd]</a></sup><span class="c8">(messageGraph: </span><span class="c21">MessageGraph</span><span class="c8">): AppGraph<br> &nbsp;}<br><br> &nbsp;</span><span class="c4">@DependencyGraph</span><span class="c8">&nbsp;</span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">MessageGraph</span><span class="c8">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br><br> &nbsp; &nbsp;</span><span class="c4">@Provides</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideMessage</span><span class="c8">(): String = </span><span class="c34">&quot;Hello, world!&quot;</span><span class="c8"><br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>Like Dagger, non- </span><span class="c13">@Provides</span><span class="c3">&nbsp;instance dependencies can be any type. Metro will treat accessor candidates of these types as usable dependencies.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br><br> &nbsp;</span><span class="c4">@DependencyGraph</span><span class="c8">.Factory<br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;interface Factory {<br> &nbsp; &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">create</span><span class="c8">(messageProvider: </span><span class="c21">MessageProvider</span><span class="c8">): AppGraph<br> &nbsp;}<br><br> &nbsp;</span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">MessageProvider</span><span class="c8">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>Graph factories can be created with the </span><span class="c13">createGraphFactory()</span><span class="c3">&nbsp;intrinsic.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c12">val</span><span class="c8 c23">&nbsp;messageGraph =</span></p><p class="c35"><span class="c8 c23">&nbsp; createGraphFactory&lt;AppGraph.Factory&gt;()</span></p><p class="c35"><span class="c8">&nbsp; &nbsp; .create(</span><span class="c34">&quot;Hello, world!&quot;</span><span class="c8">)</span></p></td></tr></table><h4 class="c1" id="h.9dxm085tp0ts"><span class="c18">Implementation Notes</span></h4><p class="c22"><span class="c3">Dependency graph code gen is designed to largely match how Dagger components are generated.</span></p><ul class="c19 lst-kix_o6z0gnpm11dy-0 start"><li class="c7 li-bullet-0"><span>Dependencies are traversed from public accessors and </span><span class="c13">inject()</span><span class="c3">&nbsp;functions.</span></li><li class="c7 li-bullet-0"><span>Metro generates </span><span>Provider Factory classes</span><sup><a href="#cmnt57" id="cmnt_ref57">[be]</a></sup><sup><a href="#cmnt58" id="cmnt_ref58">[bf]</a></sup><sup><a href="#cmnt59" id="cmnt_ref59">[bg]</a></sup><sup><a href="#cmnt60" id="cmnt_ref60">[bh]</a></sup><sup><a href="#cmnt61" id="cmnt_ref61">[bi]</a></sup><span class="c3">&nbsp;for each provider. These should be generated at the same time that the provider is compiled so that their factory classes. This is for two primary purposes:</span></li></ul><ul class="c19 lst-kix_o6z0gnpm11dy-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">They can be reused to avoid code duplication</span></li><li class="c22 c24 li-bullet-0"><span class="c3">Metro can copy default values for provider values over to the generated factory to support optional bindings. Since default values may refer to private references, we must generate these factories as nested classes.</span></li></ul><ul class="c19 lst-kix_o6z0gnpm11dy-0"><li class="c7 li-bullet-0"><span>Metro generates a graph </span><span class="c30">impl</span><span class="c3">&nbsp;class that holds all aggregated bindings and manages scoping.</span></li><li class="c7 li-bullet-0"><span>Scoped bindings are stored in provider fields backed by </span><span class="c13">DoubleCheck</span><span class="c3">.</span></li><li class="c7 li-bullet-0"><span class="c3">Reused unscoped providers instances are stored in reusable fields.</span></li><li class="c7 li-bullet-0"><span class="c13">@Provides</span><span>&nbsp;factory parameters are stored in a field backed by </span><span class="c13">InstanceFactory</span><span class="c3">.</span></li><li class="c7 li-bullet-0"><span class="c3">Multibindings create new collection instances every time.</span></li><li class="c7 li-bullet-0"><span class="c3">Multibinding providers are not accessible as standalone bindings.</span></li></ul><h3 class="c39" id="h.zb8tk8ayh69d"><span class="c13">@Provides</span></h3><p class="c22"><span>Providers can be defined in graphs or supertypes that graphs extend. </span><span>Defining them in supertypes allows for them to be reused across multiple graphs and organize providers into logic groups. This is similar to how modules in Dagger work.</span><sup><a href="#cmnt62" id="cmnt_ref62">[bj]</a></sup><sup><a href="#cmnt63" id="cmnt_ref63">[bk]</a></sup><sup><a href="#cmnt64" id="cmnt_ref64">[bl]</a></sup></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">NetworkProviders</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c4">@Provides</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideHttpClient</span><span class="c8">(): HttpClient = HttpClient()<br>}<br><br></span><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;: </span><span class="c21">NetworkProviders</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>Providers should be </span><span class="c13">private</span><span class="c3">&nbsp;by default.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>TIP: It&rsquo;s recommended to </span><span class="c30">not</span><span>&nbsp;call providers from each other.</span></p><h4 class="c1" id="h.qy1c2ebck3wj"><span class="c18">Overrides</span></h4><p class="c22"><span>It is an error to override providers declarations. While it can be enticing for testing reasons to try to replicate Dagger 1&rsquo;s </span><span class="c30">module overrides</span><span>, it quickly becomes difficult to reason about in code gen.</span><sup><a href="#cmnt65" id="cmnt_ref65">[bm]</a></sup></p><ul class="c19 lst-kix_x2grhxcoumgd-0 start"><li class="c7 li-bullet-0"><span class="c3">What if you override with sub/supertypes?</span></li><li class="c7 li-bullet-0"><span class="c3">What if your override&rsquo;s implementation needs different dependencies?</span></li></ul><p class="c5"><span class="c3"></span></p><p class="c22"><span>To the testing end, it is recommended to instead leverage the </span><span class="c13">DependencyGraph.excludes</span><span>&nbsp;+ </span><span class="c13">ContributesTo.replaces</span><span>&nbsp;APIs in merging.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c20">// Don&#39;t do this pattern!</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">NetworkProviders</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c4">@Provides</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideHttpClient</span><span class="c8">(): HttpClient = HttpClient()<br>}<br><br></span><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">TestAppGraph</span><span class="c8">&nbsp;: </span><span class="c21">NetworkProviders {</span><span class="c8"><br> &nbsp;</span><span class="c20">// This will fail to compile</span><span class="c8"><br> &nbsp;</span><span class="c12">override</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideHttpClient</span><span class="c8">(): HttpClient = TestHttpClient()<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><h4 class="c1" id="h.ttcxk9y6a9fr"><span class="c18">Companion Providers</span></h4><p class="c22"><span>Providers can alternatively be implemented in </span><span class="c13">companion object</span><span>s for staticization.</span><span class="c8 c23"><br></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">MessageGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br> &nbsp;</span><span class="c12">companion</span><span class="c8">&nbsp;</span><span class="c12">object</span><span class="c8">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c4">@Provides</span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c12">private</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideMessage</span><span class="c8">(): String = </span><span class="c34">&quot;Hello, world!&quot;</span><span class="c8"><br> &nbsp;}<br>}</span></p></td></tr></table><h4 class="c1" id="h.m9okmsywjywp"><span class="c18">Implementation Notes</span></h4><p class="c22"><span>private interface functions are not usually visible to downstream compilations in IR</span><sup><a href="#cmnt66" id="cmnt_ref66">[bn]</a></sup><sup><a href="#cmnt67" id="cmnt_ref67">[bo]</a></sup><span>. To work around this, Metro will use a </span><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/JetBrains/kotlin/blob/b2bceb12ef57664c4f9b168157c3a097a81a6e5f/compiler/ir/backend.common/src/org/jetbrains/kotlin/backend/common/extensions/IrGeneratedDeclarationsRegistrar.kt%23L26&amp;sa=D&amp;source=editors&amp;ust=1762461866439602&amp;usg=AOvVaw03mVgWAJm5hCygcnDx25O5">new API in Kotlin 2.1.20</a></span><span class="c3">&nbsp;to add custom metadata to the parent class to denote these private providers&rsquo; existence and where to find them.</span></p><h3 class="c39" id="h.638p33j2q6b7"><span class="c14">Injection Types</span></h3><p class="c22"><span class="c3">Metro supports multiple common injection types.</span></p><h4 class="c1" id="h.3ymtkz1q9fp1"><span class="c18">Constructor Injection</span></h4><p class="c22"><span class="c3">Most types should use constructor injection if possible. For this case, you can annotate either a class itself (if it has exactly one, primary constructor) or exactly one specific constructor.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">ClassInjected</span><span class="c8"><br><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">SpecificConstructorInjection</span><span class="c8">(</span><span class="c12">val</span><span class="c8">&nbsp;text: String) {<br> &nbsp;</span><span class="c4">@Inject</span><span class="c8">&nbsp;</span><span class="c12">constructor</span><span class="c8">(value: </span><span class="c31">Int</span><span class="c8">) : </span><span class="c12">this</span><span class="c8">(value.toString())<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Constructor-injected classes can be instantiated+managed entirely by Metro and encourages immutability.</span></p><h4 class="c1" id="h.sm71ct119hx3"><span>Assisted Injection</span><sup><a href="#cmnt68" id="cmnt_ref68">[bp]</a></sup><sup><a href="#cmnt69" id="cmnt_ref69">[bq]</a></sup><sup><a href="#cmnt70" id="cmnt_ref70">[br]</a></sup><sup><a href="#cmnt71" id="cmnt_ref71">[bs]</a></sup><sup><a href="#cmnt72" id="cmnt_ref72">[bt]</a></sup><sup><a href="#cmnt73" id="cmnt_ref73">[bu]</a></sup><sup><a href="#cmnt74" id="cmnt_ref74">[bv]</a></sup><sup><a href="#cmnt75" id="cmnt_ref75">[bw]</a></sup></h4><p class="c22"><span>For types that require dynamic dependencies at instantiation, assisted injection can be used to supply these inputs. In this case - an injected constructor (or class with one constructor) must be annotated with </span><span class="c13">@</span><sup><a href="#cmnt76" id="cmnt_ref76">[bx]</a></sup><sup><a href="#cmnt77" id="cmnt_ref77">[by]</a></sup><sup><a href="#cmnt78" id="cmnt_ref78">[bz]</a></sup><sup><a href="#cmnt79" id="cmnt_ref79">[ca]</a></sup><sup><a href="#cmnt80" id="cmnt_ref80">[cb]</a></sup><sup><a href="#cmnt81" id="cmnt_ref81">[cc]</a></sup><sup><a href="#cmnt82" id="cmnt_ref82">[cd]</a></sup><sup><a href="#cmnt83" id="cmnt_ref83">[ce]</a></sup><sup><a href="#cmnt84" id="cmnt_ref84">[cf]</a></sup><span class="c13">Inject</span><span>, assisted parameters annotated with </span><span class="c13">@Assisted</span><span class="c3">, and a factory interface or abstract class with one single abstract function that accepts these assisted parameters and returns the target class.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">HttpClient</span><span class="c8">(<br> &nbsp;</span><span class="c4">@Assisted</span><span class="c8">&nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;timeout: Duration,<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;cache: Cache<br>) {<br> &nbsp;</span><span class="c4">@AssistedFactory</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;interface Factory {<br> &nbsp; &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">create</span><span class="c8">(timeout: </span><span class="c21">Duration</span><span class="c8">): HttpClient<br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>Then, the </span><span class="c13">@AssistedFactory</span><span class="c3">-annotated type can be accessed from the dependency graph.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">ApiClient</span><span class="c8">(</span><span class="c12">val</span><span class="c8">&nbsp;httpClientFactory: HttpClient.Factory) {<br> &nbsp;</span><span class="c12">private</span><span class="c8">&nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;httpClient = httpClientFactory.create(</span><span class="c28">30.</span><span class="c8">seconds)<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>Like Dagger, the </span><span class="c13">@Assisted</span><span>&nbsp;parameters can take optional </span><span class="c13">value</span><span class="c3">&nbsp;keys to disambiguate matching types.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">HttpClient</span><span class="c8">(<br> &nbsp;</span><span class="c4">@Assisted(&quot;connect&quot;)</span><sup><a href="#cmnt85" id="cmnt_ref85">[cg]</a></sup><sup><a href="#cmnt86" id="cmnt_ref86">[ch]</a></sup><sup><a href="#cmnt87" id="cmnt_ref87">[ci]</a></sup><sup><a href="#cmnt88" id="cmnt_ref88">[cj]</a></sup><sup><a href="#cmnt89" id="cmnt_ref89">[ck]</a></sup><sup><a href="#cmnt90" id="cmnt_ref90">[cl]</a></sup><sup><a href="#cmnt91" id="cmnt_ref91">[cm]</a></sup><sup><a href="#cmnt92" id="cmnt_ref92">[cn]</a></sup><sup><a href="#cmnt93" id="cmnt_ref93">[co]</a></sup><span class="c8">&nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;connectTimeout: Duration,<br> &nbsp;</span><span class="c4">@Assisted(&quot;request&quot;)</span><span class="c8">&nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;requestTimeout: Duration,<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;cache: Cache<br>) {<br> &nbsp;</span><span class="c4">@AssistedFactory</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;interface Factory {<br> &nbsp; &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">create</span><span class="c8">(<br> &nbsp; &nbsp; &nbsp;</span><span class="c4">@Assisted(&quot;connect&quot;) </span><span class="c8">connectTimeout: </span><span class="c21">Duration</span><span class="c8">,<br> &nbsp; &nbsp; &nbsp;</span><span class="c4">@Assisted(&quot;request&quot;)</span><span class="c8">&nbsp;</span><span class="c8">requestTimeout: </span><span class="c21">Duration</span><span class="c8">,<br> &nbsp; &nbsp;): HttpClient<br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><h5 class="c45" id="h.m7kzefhdvber"><span class="c23 c32">Automatic Assisted Factory Generation</span></h5><p class="c22"><span>As of </span><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/ZacSweers/lattice/pull/60&amp;sa=D&amp;source=editors&amp;ust=1762461866444930&amp;usg=AOvVaw3_rVhRyul_VLnq8HGLVtQu">this PR</a></span><span>, there is a feature (behind a compiler option) to let Metro </span><span class="c30">automatically</span><span>&nbsp;generate assisted factory interfaces for </span><span class="c13">@Inject</span><span>-annotated constructors that contain </span><span class="c13">@Assisted</span><span>-annotated parameters. This should save boilerplate in most cases, but may not be suitable for all cases</span><sup><a href="#cmnt94" id="cmnt_ref94">[cp]</a></sup><sup><a href="#cmnt95" id="cmnt_ref95">[cq]</a></sup><span class="c3">. Cases where you may not want this include:</span></p><ol class="c19 lst-kix_hxj86hw44hwz-0 start" start="1"><li class="c7 li-bullet-0"><span class="c3">You want assisted factories to conform to a common interface.</span></li><li class="c7 li-bullet-0"><span>Likely in combination with #1, you may want to contribute these factories to multibindings of some sort and thus need to annotate them with </span><span class="c13">@IntoSet</span><span class="c3">, etc.</span></li></ol><p class="c5"><span class="c3"></span></p><h4 class="c1" id="h.dq3ob0t7gxrf"><span>Member Injection</span><sup><a href="#cmnt96" id="cmnt_ref96">[cr]</a></sup><sup><a href="#cmnt97" id="cmnt_ref97">[cs]</a></sup></h4><p class="c22"><span>Metro supports </span><span class="c30">member injection</span><span class="c3">&nbsp;to inject mutable properties or functions post-construction or into existing class instances.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">This can be useful for classes that cannot be constructor-injected, for example Android Activity classes (on older SDK versions) as well as constructor-injected classes that perhaps don&rsquo;t want or need to expose certain types directly in their constructors.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>TIP: Unlike Dagger and kotlin-inject, injected members in Metro can be </span><span class="c13">private</span><span class="c3">.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>NOTE: Member function injection does not (currently) support default values.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">ProfileActivity</span><span class="c8">&nbsp;: </span><span class="c21">Activity</span><span class="c8">() {<br> &nbsp;</span><span class="c20">// Property injection</span><span class="c8"><br> &nbsp;</span><span class="c4">@Inject</span><span class="c8">&nbsp;</span><span class="c12">private</span><span class="c8">&nbsp;</span><span class="c12">lateinit</span><span class="c8">&nbsp;</span><span class="c12">var</span><span class="c8">&nbsp;db: UserDatabase<br><br> &nbsp;</span><span class="c4">@Inject</span><span class="c8">&nbsp;</span><span class="c12">private</span><span class="c8">&nbsp;</span><span class="c12">var</span><span class="c8">&nbsp;notifications: Notifications? = </span><span class="c28">null</span><span class="c8"><br><br> &nbsp;</span><span class="c20">// Function injection</span><span class="c8"><br> &nbsp;</span><span class="c4">@Inject</span><span class="c8">&nbsp;</span><span class="c12">private</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">injectUser</span><span class="c8">(user: </span><span class="c21">User</span><span class="c8">) {<br> &nbsp; &nbsp;</span><span class="c20">// ...</span><span class="c8"><br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Like Dagger, these classes can be injected via multiple avenues.</span></p><p class="c5 c49"><span class="c3"></span></p><ol class="c19 lst-kix_ulfgfs8t0p10-0 start" start="1"><li class="c7 li-bullet-0"><span>In constructor-injected types, </span><span class="c13">@Inject</span><span>-annotated</span><span>&nbsp;members are injected </span><span class="c30">automatically</span><span class="c3">.</span></li></ol><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c20">// Injection with constructor injection</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">ProfileInjector</span><span class="c8">(...) {<br> &nbsp;</span><span class="c20">// Automatically injected during constructor injection</span><span class="c8"><br> &nbsp;</span><span class="c4">@Inject</span><span class="c8">&nbsp;</span><span class="c12">private</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">injectUser</span><span class="c8">(value: </span><span class="c21">String</span><span class="c8">)<br>}</span></p></td></tr></table><p class="c22"><span class="c3">In these cases, Metro will automatically inject these members automatically and immediately after instantiation during constructor injection.</span></p><p class="c5"><span class="c3"></span></p><ol class="c19 lst-kix_ulfgfs8t0p10-0" start="2"><li class="c45 c47 li-bullet-0"><h5 id="h.55ej261ttf66" style="display:inline"><span>Exposing a </span><span class="c13">fun inject(target: ProfileActivity)</span><span class="c23 c32">&nbsp;function on the graph</span></h5></li></ol><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c20">// Graph inject() functions</span><span class="c8"><br></span><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c20">// ...</span><span class="c8"><br><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">inject</span><span class="c8">(target: </span><span class="c21">ProfileActivity</span><span class="c8">)<br>}<br><br></span><span class="c20">// Somewhere else</span><span class="c8"><br></span><span class="c12">val</span><span class="c8 c23">&nbsp;graph = createGraph&lt;AppGraph&gt;()<br>graph.inject(profileActivity)</span></p></td></tr></table><p class="c22"><span>With this option, you can call </span><span class="c13">graph.inject(target)</span><span class="c3">&nbsp;on the instance with members you wish to inject.</span></p><p class="c5"><span class="c3"></span></p><ol class="c19 lst-kix_ulfgfs8t0p10-0" start="3"><li class="c45 c47 li-bullet-0"><h5 id="h.8km2hxkuehw5" style="display:inline"><span>Requesting a </span><span class="c13">MembersInjector</span><span class="c23 c32">&nbsp;instance from the dependency graph.</span></h5></li></ol><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c20">// Injection with MembersInjector</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">ProfileInjector</span><span class="c8 c23">(</span></p><p class="c35"><span class="c12">&nbsp; private</span><span class="c8">&nbsp;</span><span class="c12">val</span><span class="c8 c23">&nbsp;injector: MembersInjector&lt;ProfileActivity&gt;</span></p><p class="c35"><span class="c8">) {<br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">performInjection</span><span class="c8">(activity: </span><span class="c21">ProfileActivity</span><span class="c8">) {<br> &nbsp; &nbsp;injector.inject(activity)<br> &nbsp;}<br>}</span></p></td></tr></table><p class="c22"><span>Like Dagger, option #2 is accomplished via </span><span class="c13">MembersInjector</span><span class="c3">&nbsp;interface at runtime and in code gen. This should be reserved for advanced use cases.</span></p><p class="c5"><span class="c3"></span></p><h5 class="c45" id="h.6c40hzwn9awe"><span class="c23 c32">Implementation notes</span></h5><ul class="c19 lst-kix_vvh90m5tr5ag-0 start"><li class="c7 li-bullet-0"><span>Property accessors don&rsquo;t use </span><span class="c13">get</span><span>/</span><span class="c13">set</span><span>&nbsp;names in </span><span class="c13">inject{name}()</span><span class="c3">&nbsp;function names.</span></li><li class="c7 li-bullet-0"><span class="c3">MembersInjector classes are generated as nested classes, allowing private member access.</span></li></ul><ul class="c19 lst-kix_vvh90m5tr5ag-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">This includes parent classes&rsquo; private members (!!)</span></li></ul><ul class="c19 lst-kix_vvh90m5tr5ag-0"><li class="c7 li-bullet-0"><span>Optional bindings are not supported for injected member functions currently, but may be possible in the future.</span></li></ul><h4 class="c1 c25" id="h.g7q9ltspqb1q"><span class="c18"></span></h4><h4 class="c1" id="h.d4eu6ta6i3hu"><span class="c18">Top-level Function Injection</span></h4><p class="c22"><span>Like KI, Metro supports top-level function injection. The primary use case for this is composable functions and standalone applications that run from </span><span class="c13">main</span><span>&nbsp;functions.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">App</span><span class="c8">(message: </span><span class="c21">String</span><span class="c8">) {<br> &nbsp;</span><span class="c20">// ...</span><span class="c8"><br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">To do this, Metro&rsquo;s FIR plugin will generate a concrete type that acts as a bridge for this function.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">AppClass</span><span class="c8">(<br> &nbsp;</span><span class="c12">private</span><span class="c8">&nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: Provider&lt;String&gt;<br>) {<br> &nbsp;</span><span class="c12">operator</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">invoke</span><span class="c8">() {<br> &nbsp; &nbsp;App(message())<br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Because it&rsquo;s generated in FIR, this type will be user-visible in the IDE and can then be referenced in a graph.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c30">Note that this feature requires enabling third party FIR plugins in the IDE to fully work. It will compile without it, but generated wrapper classes will be red/missing in the IDE.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>NOTE: The generated class is called </span><span class="c13">&lt;function name&gt;</span><span>&nbsp;+ </span><span class="c13">Class</span><span>&nbsp;because of a limitation in the Kotlin compiler. TODO Link issue?</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;app: AppClass<br><br> &nbsp;</span><span class="c4">@DependencyGraph</span><span class="c8">.Factory<br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;interface Factory {<br> &nbsp; &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">create</span><span class="c8">(message: </span><span class="c21">String</span><span class="c8">): AppGraph<br> &nbsp;}<br>}<br><br></span><span class="c20">// Usage</span><span class="c8"><br></span><span class="c12">val</span><span class="c8">&nbsp;app = createGraphFactory&lt;AppGraph.Factory&gt;()<br> &nbsp;.create(</span><span class="c34">&quot;Hello, world!&quot;</span><span class="c8">)<br> &nbsp;.app<br><br></span><span class="c20">// Run the app</span><span class="c8"><br>app()</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>To add assisted parameters, use </span><span class="c13">@Assisted</span><span class="c3">&nbsp;on the parameters in the function description. These will be propagated accordingly.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">App</span><span class="c8">(</span><span class="c4">@Assisted</span><span class="c8">&nbsp;message: </span><span class="c21">String</span><span class="c8">) {<br> &nbsp;</span><span class="c20">// ...</span><span class="c8"><br>}<br><br></span><span class="c20">// Generates...</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">AppClass</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">operator</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">invoke</span><span class="c8">(message: </span><span class="c21">String</span><span class="c8">) {<br> &nbsp; &nbsp;App(message)<br> &nbsp;}<br>}<br><br></span><span class="c20">// Usage</span><span class="c8"><br></span><span class="c12">val</span><span class="c8">&nbsp;app = createGraph&lt;AppGraph&gt;()<br> &nbsp;.app<br><br></span><span class="c20">// Run the app</span><span class="c8"><br>app(</span><span class="c34">&quot;Hello, world!&quot;</span><span class="c8 c23">)</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>This is particularly useful for Compose, and </span><span class="c13">@Composable</span><span class="c3">&nbsp;functions will be copied over accordingly.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Inject</span><span class="c8"><br></span><span class="c4">@Composable</span><span class="c8"><br></span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">App</span><span class="c8">(</span><span class="c4">@Assisted</span><span class="c8">&nbsp;message: </span><span class="c21">String</span><span class="c8">) {<br> &nbsp;</span><span class="c20">// ...</span><span class="c8"><br>}<br><br></span><span class="c20">// Generates...</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">AppClass</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c4">@Composable</span><span class="c8"><br> &nbsp;</span><span class="c12">operator</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">invoke</span><span class="c8">(message: </span><span class="c21">String</span><span class="c8">) {<br> &nbsp; &nbsp;App(message)<br> &nbsp;}<br>}<br><br></span><span class="c20">// Usage</span><span class="c8"><br></span><span class="c12">val</span><span class="c8">&nbsp;App = createGraph&lt;AppGraph&gt;()<br> &nbsp;.app<br><br></span><span class="c20">// Call it in composition</span><span class="c8"><br>setContent {<br> &nbsp;App(</span><span class="c34">&quot;Hello, world!&quot;</span><span class="c8 c23">)<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>Similarly, if the injected function is a </span><span class="c13">suspend</span><span>&nbsp;function, the </span><span class="c13">suspend</span><span>&nbsp;keyword will be ported to the generated </span><span class="c13">invoke()</span><span>&nbsp;function too.</span></p><h5 class="c45" id="h.gn3z1czdi14k"><span class="c23 c32">Implementation notes</span></h5><p class="c22"><span>This is fairly different from kotlin-inject&rsquo;s typealias approach. This is necessary because Metro doesn&rsquo;t use higher order function types or typealiases as qualifiers.</span><sup><a href="#cmnt98" id="cmnt_ref98">[ct]</a></sup></p><h3 class="c39" id="h.3hy8y8l8no89"><span>Scopes</span><sup><a href="#cmnt99" id="cmnt_ref99">[cu]</a></sup><sup><a href="#cmnt100" id="cmnt_ref100">[cv]</a></sup><sup><a href="#cmnt101" id="cmnt_ref101">[cw]</a></sup><sup><a href="#cmnt102" id="cmnt_ref102">[cx]</a></sup><sup><a href="#cmnt103" id="cmnt_ref103">[cy]</a></sup><sup><a href="#cmnt104" id="cmnt_ref104">[cz]</a></sup><sup><a href="#cmnt105" id="cmnt_ref105">[da]</a></sup><sup><a href="#cmnt106" id="cmnt_ref106">[db]</a></sup><sup><a href="#cmnt107" id="cmnt_ref107">[dc]</a></sup><sup><a href="#cmnt108" id="cmnt_ref108">[dd]</a></sup><sup><a href="#cmnt109" id="cmnt_ref109">[de]</a></sup><sup><a href="#cmnt110" id="cmnt_ref110">[df]</a></sup><sup><a href="#cmnt111" id="cmnt_ref111">[dg]</a></sup></h3><p class="c22"><span>Like Dagger and KI</span><sup><a href="#cmnt112" id="cmnt_ref112">[dh]</a></sup><sup><a href="#cmnt113" id="cmnt_ref113">[di]</a></sup><sup><a href="#cmnt114" id="cmnt_ref114">[dj]</a></sup><sup><a href="#cmnt115" id="cmnt_ref115">[dk]</a></sup><span>, Metro supports </span><span class="c30">scopes</span><span>&nbsp;to limit instances of types on the dependency graph. A scope is any annotation annotated with </span><span class="c13">@Scope</span><span>, with a </span><span>convenience</span><span>&nbsp;</span><span class="c13">@Singleton</span><span class="c3">&nbsp;scope available in Metro&rsquo;s runtime.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Scopes must be applied to either the injected class or the provider function providing that binding. They must also match the graph that they are used in.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@</span><span class="c4">Singleton</span><sup><a href="#cmnt116" id="cmnt_ref116">[dl]</a></sup><sup><a href="#cmnt117" id="cmnt_ref117">[dm]</a></sup><span class="c8"><br></span><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">abstract</span><span class="c8">&nbsp;</span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">private</span><span class="c8">&nbsp;</span><span class="c12">var</span><span class="c8">&nbsp;counter = </span><span class="c28">0</span><span class="c8"><br><br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;count: </span><span class="c31">Int</span><span class="c8"><br><br> &nbsp;</span><span class="c4">@Singleton</span><span class="c8">&nbsp;</span><span class="c4">@Provides</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideCount</span><span class="c8">() = counter++<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>In the above example, multiple calls to </span><span class="c13">AppGraph.count</span><span>&nbsp;will always return 0 because the returned value from </span><span class="c13">provideCount()</span><span>&nbsp;will be cached in the </span><span class="c13">AppGraph</span><span class="c3">&nbsp;instance the first time it&rsquo;s called.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>It is an error for an unscoped graph to access scoped bindings.</span><span class="c8 c23"><br></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c20">// This is an error!</span><span class="c8"><br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;exampleClass: ExampleClass<br>}<br><br></span><span class="c4">@Singleton</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">ExampleClass</span></p></td></tr></table><p class="c35 c11"><span class="c8 c23"></span></p><p class="c22"><span class="c3">It is also an error for a scoped graph to access scoped bindings whose scope does not match.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Scope</span><span class="c8">&nbsp;</span><span class="c12">annotation</span><span class="c8">&nbsp;</span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">UserScope</span><span class="c8"><br><br></span><span class="c4">@Singleton</span><span class="c8"><br></span><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c20">// This is an error!</span><span class="c8"><br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;exampleClass: ExampleClass<br>}<br><br></span><span class="c4">@UserScope</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">ExampleClass</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Like Dagger, graphs can have multiple scopes that they support.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Scope</span><span class="c8">&nbsp;</span><span class="c12">annotation</span><span class="c8">&nbsp;</span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">SingleIn</span><span class="c8">(scope: KClass&lt;*&gt;)<br><br></span><span class="c4">@Singleton</span><span class="c8"><br></span><span class="c4">@SingleIn(AppScope::class)</span><span class="c8"><br></span><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c20">// This is ok</span><span class="c8"><br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;exampleClass: ExampleClass<br>}<br><br></span><span class="c4">@SingleIn(AppScope::class)</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">ExampleClass</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><h3 class="c39" id="h.p5vwal4ctxq6"><span>Metro</span><span class="c14">&nbsp;Intrinsics</span></h3><p class="c22"><span>Like Dagger, Metro supports injection of bindings wrapped in intrinsic types. Namely - </span><span class="c13">Provider</span><span>&nbsp;and </span><span class="c13">Lazy</span><span class="c3">. These are useful for deferring creation/initialization of dependencies. These only need to be requested at the injection site, Metro&rsquo;s code gen will generate all the necessary stitching to fulfill that request.</span></p><h4 class="c1" id="h.7iotsmsj09ak"><span class="c18">Provider</span></h4><p class="c22"><span class="c13">Provider</span><span>&nbsp;is like Dagger&rsquo;s </span><span class="c13">Provider</span><span>&nbsp;&mdash; it is a simple interface who&rsquo;s </span><span class="c13">invoke()</span><span>&nbsp;call returns a new instance every time. If the underlying binding is scoped, then the same (scoped) instance is returned every time </span><span class="c13">invoke()</span><span class="c3">&nbsp;is called.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">HttpClient</span><span class="c8">(</span><span class="c12">val</span><span class="c8">&nbsp;cacheProvider: Provider&lt;Cache&gt;) {<br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">createCache</span><span class="c8">() {<br> &nbsp; &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;cache = cacheProvider()<br> &nbsp;}<br>}</span></p></td></tr></table><h4 class="c1" id="h.2ap2m6ze8r5i"><span class="c18">Lazy</span></h4><p class="c22"><span class="c13">Lazy</span><sup><a href="#cmnt118" id="cmnt_ref118">[dn]</a></sup><sup><a href="#cmnt119" id="cmnt_ref119">[do]</a></sup><sup><a href="#cmnt120" id="cmnt_ref120">[dp]</a></sup><sup><a href="#cmnt121" id="cmnt_ref121">[dq]</a></sup><span>&nbsp;is Kotlin&rsquo;s standard library </span><span class="c13">Lazy</span><span class="c3">. It lazily computes a value the first time it&rsquo;s evaluated and is thread-safe.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">HttpClient</span><span class="c8">(</span><span class="c12">val</span><span class="c8">&nbsp;cacheProvider: Lazy&lt;Cache&gt;) {<br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">createCache</span><span class="c8">() {<br> &nbsp; &nbsp;</span><span class="c20">// The value is computed once and cached after</span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;cache = cacheProvider.value<br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>Note that </span><span class="c13">Lazy</span><span>&nbsp;is different from </span><span class="c30">scoping</span><span>&nbsp;in that it is confined to the scope of the </span><span class="c30">injected type</span><span>, rather than the component instance itself. There is functionally no difference between injecting a </span><span class="c13">Provider</span><span>&nbsp;or </span><span class="c13">Lazy</span><span>&nbsp;of a </span><span class="c30">scoped</span><span>&nbsp;binding. A </span><span class="c13">Lazy</span><span>&nbsp;of a </span><span>scoped binding can still be useful to defer initialization</span><sup><a href="#cmnt122" id="cmnt_ref122">[dr]</a></sup><sup><a href="#cmnt123" id="cmnt_ref123">[ds]</a></sup><span>. The underlying implementation in Metro&rsquo;s </span><span class="c13">DoubleCheck</span><span class="c3">&nbsp;prevents double memoization in this case.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c30">&gt; Why doesn&rsquo;t </span><span class="c13 c30">Provider</span><span class="c30">&nbsp;just use a property like </span><span class="c13 c30">Lazy</span><span class="c30 c42">?</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>A property is appropriate for </span><span class="c13">Lazy</span><span>&nbsp;because it fits the definition of being a </span><span class="c30">computed</span><span>&nbsp;value that is idempotent for repeat calls. Metro opts to make its </span><span class="c13">Provider</span><span>&nbsp;use an </span><span class="c13">invoke()</span><span class="c3">&nbsp;function because it does not abide by that contract.</span></p><p class="c5"><span class="c3"></span></p><h4 class="c1" id="h.1oohtb5l2vhv"><span>Providers of Lazy</span><sup><a href="#cmnt124" id="cmnt_ref124">[dt]</a></sup><sup><a href="#cmnt125" id="cmnt_ref125">[du]</a></sup><sup><a href="#cmnt126" id="cmnt_ref126">[dv]</a></sup><sup><a href="#cmnt127" id="cmnt_ref127">[dw]</a></sup><sup><a href="#cmnt128" id="cmnt_ref128">[dx]</a></sup><sup><a href="#cmnt129" id="cmnt_ref129">[dy]</a></sup></h4><p class="c22"><span>Metro</span><span>&nbsp;supports combining </span><span class="c13">Provider</span><span>&nbsp;and </span><span class="c13">Lazy</span><span>&nbsp;to inject </span><span class="c13">Provider&lt;Lazy&lt;T&gt;&gt;</span><span>. On unscoped bindings this means the provider will return a new </span><span>deferrable</span><span>&nbsp;computable value (i.e. a new Lazy). Meanwhile </span><span class="c13">Lazy&lt;Provider&lt;T&gt;&gt;</span><span>&nbsp;is meaningless and not supported.</span></p><h3 class="c39" id="h.gqgpbkq4doq7"><span class="c14">Bindings</span></h3><h4 class="c1" id="h.c9i9294cpu1n"><span class="c18">Qualifiers</span></h4><p class="c22"><span>Like Dagger and KI, Metro supports </span><span class="c30">qualifier annotations</span><span>&nbsp;to allow disambiguation of types. These are applied at injection and provision sites. A qualifier annotation is any annotation annotated with </span><span class="c13">@Qualifier</span><span>. For convenience, there is an included </span><span class="c13">@Named</span><span class="c3">&nbsp;qualifier available in Metro&rsquo;s runtime that can be used too.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">A &ldquo;type key&rdquo; in Metro is composed of a concrete type and (if any) qualifier annotation attached to it.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;int: </span><span class="c31">Int</span><span class="c8"><br> &nbsp;</span><span class="c4">@Named(&quot;named&quot;)</span><span class="c8">&nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;namedInt: </span><span class="c31">Int</span><span class="c8"><br><br> &nbsp;</span><span class="c4">@Provides</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideInt</span><span class="c8">(): </span><span class="c31">Int</span><span class="c8">&nbsp;= </span><span class="c28">3</span><span class="c8"><br><br> &nbsp;</span><span class="c4">@Provides</span><span class="c8"><br> &nbsp;</span><span class="c4">@Named(&quot;named&quot;)</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideNamedInt</span><span class="c8">(): </span><span class="c31">Int</span><span class="c8">&nbsp;= </span><span class="c28">4</span><span class="c8"><br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><h4 class="c1" id="h.2p95qe2t0cz4"><span>@Binds</span></h4><p class="c22"><span class="c3">In many cases, a developer may have an implementation type on the graph that they want to expose as just its supertype.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>Like Dagger, Metro supports this with </span><span class="c13">@Binds</span><span>.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">For these cases, an abstract provider can be specified with the following conditions.</span></p><ul class="c19 lst-kix_6d03k7jdfpim-0 start"><li class="c7 li-bullet-0"><span class="c3">It must be abstract</span></li><li class="c7 li-bullet-0"><span>It must define one extension receiver that is a subtype of its provided type</span><sup><a href="#cmnt130" id="cmnt_ref130">[dz]</a></sup><sup><a href="#cmnt131" id="cmnt_ref131">[ea]</a></sup><sup><a href="#cmnt132" id="cmnt_ref132">[eb]</a></sup><sup><a href="#cmnt133" id="cmnt_ref133">[ec]</a></sup><sup><a href="#cmnt134" id="cmnt_ref134">[ed]</a></sup></li></ul><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8 c23">&nbsp;message: Message</span></p><p class="c35"><span class="c8"><br> &nbsp;</span><span class="c20">// Bind MessageImpl as Message</span><span class="c8"><br> &nbsp;</span><span class="c4">@Binds</span><span class="c8">&nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;MessageImpl.bind: Message<br><br> &nbsp;</span><span class="c4">@Provides</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideText</span><span class="c8">(): String = </span><span class="c34">&quot;Hello, world!&quot;</span><span class="c8"><br>}<br><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">MessageImpl</span><span class="c8">(</span><span class="c12">val</span><span class="c8 c23">&nbsp;text: String) : Message</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>If you want to limit access to these from your API, you can make these declarations </span><span class="c13">private</span><span>&nbsp;and just return </span><span class="c13">this</span><span>. Note it&rsquo;s still important to annotate them with </span><span class="c13">@Binds</span><span>&nbsp;so that the Metro compiler understands its intent! Otherwise, it&rsquo;s an error to </span><span class="c30">implement</span><span class="c3">&nbsp;these declarations.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c13">@Binds</span><span class="c3">&nbsp;declarations can also declare multibinding annotations.</span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;messages: Message<br><br> &nbsp;</span><span class="c4">@Binds</span><span class="c8">&nbsp;</span><span class="c4">@IntoSet</span><span class="c8">&nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;MessageImpl.bind: Message<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>NOTE: In theory, you can implement a provider with a getter that replicates this (similar to how kotlin-inject uses </span><span class="c13">@get:Provider</span><span>&nbsp;+ </span><span class="c13">this</span><span>), but this will be an error in FIR because Metro can generate more efficient code at compile-time if you use </span><span class="c13">@Binds</span><span class="c3">. This is because Metro can avoid calling the function entirely and just use this information at compile-time to optimize the generated code.</span></p><p class="c5"><span class="c3"></span></p><h4 class="c1" id="h.t01h76s2y87x"><span class="c18">Multibindings</span></h4><p class="c22"><span>Like Dagger and KI, Metro supports </span><span class="c13">Set</span><span>&nbsp;and </span><span class="c13">Map</span><span>&nbsp;multibindings. Multibindings are collections of bindings of a common type. Multibindings are implicitly declared by the existence of providers annotated with </span><span class="c13">@IntoSet</span><span>, </span><span class="c13">@IntoMap</span><span>, or </span><span class="c13">@ElementsIntoSet</span><span class="c3">.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">SetMultibinding</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c20">// contains a set of [1, 2, 3, 4]</span><span class="c8"><br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;ints: Set&lt;</span><span class="c31">Int</span><span class="c8">&gt;<br><br> &nbsp;</span><span class="c4">@Provides</span><span class="c8">&nbsp;</span><span class="c4">@IntoSet</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideInt1</span><span class="c8">() = </span><span class="c28">1</span></p><p class="c35 c11"><span class="c8 c23"></span></p><p class="c35"><span class="c8">&nbsp; </span><span class="c4">@Provides</span><span class="c8">&nbsp;</span><span class="c4">@IntoSet</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideInt2</span><span class="c8">() = </span><span class="c23 c28">2</span></p><p class="c35"><span class="c8"><br> &nbsp;</span><span class="c4">@Provides</span></p><p class="c35"><span class="c8">&nbsp; </span><span class="c4">@ElementsIntoSet</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideInts</span><span class="c8">() = setOf(</span><span class="c28">3</span><span class="c8">, </span><span class="c28">4</span><span class="c8 c23">)<br>}</span></p></td></tr></table><p class="c35 c11"><span class="c8 c23"></span></p><p class="c22"><span>Map multibindings use </span><span class="c13">@IntoMap</span><span>&nbsp;and require a </span><span class="c30">map key</span><span>&nbsp;annotation. Map keys are any annotation annotated with </span><span class="c13">@MapKey</span><span>. Metro&rsquo;s runtime includes a number of common ones like </span><span class="c13">@ClassKey</span><span>, </span><span class="c13">@StringKey</span><span>, </span><span class="c13">@IntKey</span><span>, </span><span class="c13">@LongKey</span><span>, and </span><span class="c13">@LazyClassKey</span><span>*.</span></p><p class="c35 c11"><span class="c8 c23"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">MapMultibinding</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c20">// contains a map of {1:1, 2:2}</span><span class="c8"><br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;ints: Map&lt;</span><span class="c31">Int</span><span class="c8">, </span><span class="c31">Int</span><span class="c8">&gt;<br><br> &nbsp;</span><span class="c4">@Provides</span><span class="c8"><br> &nbsp;</span><span class="c4">@IntoMap</span><span class="c8"><br> &nbsp;</span><span class="c4">@IntKey(1)</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideInt1</span><span class="c8">() = </span><span class="c23 c28">1</span></p><p class="c35"><span class="c8"><br> &nbsp;</span><span class="c4">@Provides</span><span class="c8"><br> &nbsp;</span><span class="c4">@IntoMap</span><span class="c8">&nbsp;<br> &nbsp;</span><span class="c4">@MapKey(2)</span><span class="c8"><br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideInt2</span><span class="c8">() = </span><span class="c28">2</span><span class="c8 c23"><br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>Alternatively, they can be declared with an </span><span class="c13">@Multibinds</span><span class="c3">-annotated accessor property/function in a component. This member will be implemented by the Metro compiler and is useful for scenarios where the multibinding may be empty.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">MapMultibinding</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c4">@Multibinding</span><span class="c8"><br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;ints: Map&lt;</span><span class="c31">Int</span><span class="c8">, </span><span class="c31">Int</span><span class="c8">&gt;<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Multibinding collections are immutable at runtime and cannot be defined as mutable at request sites.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>Map multibindings support injecting </span><span class="c30">map providers</span><span>, where the value type can be wrapped in </span><span class="c13">Provider</span><span class="c3">.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">MapMultibinding</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c4">@Multibinding</span><span class="c8"><br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;ints: Map&lt;</span><span class="c31">Int</span><span class="c8">, Provider&lt;</span><span class="c31">Int</span><span class="c8">&gt;&gt;<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><h4 class="c1" id="h.h0m0l722y3xy"><span class="c18">Optional Dependencies</span></h4><p class="c22"><span>Metro</span><span>&nbsp;supports optional dependencies by leaning on Kotlin&rsquo;s native support for default parameter values. </span><span>These are checked at injection sites and are allowed to be missing from the dependency graph when performing a lookup at validation/code-gen time.</span><sup><a href="#cmnt135" id="cmnt_ref135">[ee]</a></sup><sup><a href="#cmnt136" id="cmnt_ref136">[ef]</a></sup><sup><a href="#cmnt137" id="cmnt_ref137">[eg]</a></sup><sup><a href="#cmnt138" id="cmnt_ref138">[eh]</a></sup></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>The below example would, since there is no </span><span class="c13">Int</span><span>&nbsp;binding provided, provide a message of </span><span class="c13">Count: -1</span><span class="c3">.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br><br> &nbsp;</span><span class="c4">@Provides</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideMessage</span><span class="c8">(count: </span><span class="c21">Int</span><span class="c8">&nbsp;= </span><span class="c28">-1</span><span class="c8">) = </span><span class="c34">&quot;Count: </span><span class="c28">$count</span><span class="c34">&quot;</span><span class="c8"><br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>Dagger supports a similar feature via </span><span class="c13">@BindsOptionalOf</span><span class="c3">, but requires a separate declaration of this optional dependency to the graph.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">KI supports the same feature.</span></p><p class="c5"><span class="c3"></span></p><h5 class="c45" id="h.vso4t86fxoaw"><span>Implementation notes</span><sup><a href="#cmnt139" id="cmnt_ref139">[ei]</a></sup><sup><a href="#cmnt140" id="cmnt_ref140">[ej]</a></sup><sup><a href="#cmnt141" id="cmnt_ref141">[ek]</a></sup></h5><p class="c22"><span class="c3">While kotlin-inject can support this by simply invoking functions with omitted arguments, Metro has to support this in generated factories.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">To accomplish this, Metro will slightly modify how generated provider/constructor injection factory classes look compared to Dagger. Since we are working in IR, we can copy the default value expressions from the source function/constructor to the factory&rsquo;s newInstance and create() functions. This in turn allows calling generated graphs to simply omit absent binding arguments from their creation calls. This is a tried and tested pattern used by other first party plugins, namely kotlinx-serialization.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">There are a few cases that need to be handled here:</span></p><ul class="c19 lst-kix_6lpac386yqkw-0 start"><li class="c7 li-bullet-0"><span class="c3">Expressions may reference previous parameters or instance members. To support this, we&rsquo;ll transform them in IR to point at new parameters in those functions.</span></li><li class="c7 li-bullet-0"><span class="c3">Expressions may reference private instance members. To support this, Metro factories are generated as nested classes within the source class or graph.</span></li></ul><ul class="c19 lst-kix_6lpac386yqkw-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">This does depart from how dagger factories work, but if we ever wanted to have some sort of interop for that we could always generate bridging factory classes in the places dagger expects later.</span></li></ul><ul class="c19 lst-kix_6lpac386yqkw-0"><li class="c7 li-bullet-0"><span>Parameters in </span><span class="c13">create()</span><span>&nbsp;need to be wrapped in </span><span class="c13">Provider</span><span>&nbsp;calls. This means that for cases where they back-reference other parameters, those will need to be transformed into </span><span class="c13">invoke()</span><span class="c3">&nbsp;calls on those providers too.</span></li></ul><p class="c5"><span class="c3"></span></p><h3 class="c39" id="h.h3yj7pph9xo0"><span>Aggregation (aka Anvil)</span><sup><a href="#cmnt142" id="cmnt_ref142">[el]</a></sup><sup><a href="#cmnt143" id="cmnt_ref143">[em]</a></sup><sup><a href="#cmnt144" id="cmnt_ref144">[en]</a></sup><sup><a href="#cmnt145" id="cmnt_ref145">[eo]</a></sup><sup><a href="#cmnt146" id="cmnt_ref146">[ep]</a></sup></h3><p class="c22"><span>Metro supports Anvil-style aggregation in graphs</span><sup><a href="#cmnt147" id="cmnt_ref147">[eq]</a></sup><span>&nbsp;via </span><span class="c13">@ContributesTo</span><span>&nbsp;and </span><span class="c13">@ContributesBinding</span><span>&nbsp;annotations. As aggregation is a first-class citizen of Metro&rsquo;s API, there is no </span><span class="c13">@MergeComponent</span><span>&nbsp;annotation like in Anvil. Instead, </span><span class="c13">@DependencyGraph</span><span class="c3">&nbsp;defines which contribution scope it supports directly.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph(</span><span class="c4">scope = AppScope::class</span><sup><a href="#cmnt148" id="cmnt_ref148">[er]</a></sup><sup><a href="#cmnt149" id="cmnt_ref149">[es]</a></sup><sup><a href="#cmnt150" id="cmnt_ref150">[et]</a></sup><sup><a href="#cmnt151" id="cmnt_ref151">[eu]</a></sup><sup><a href="#cmnt152" id="cmnt_ref152">[ev]</a></sup><sup><a href="#cmnt153" id="cmnt_ref153">[ew]</a></sup><span class="c4">)</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span></p></td></tr></table><p class="c22"><span>When a graph declares a </span><span class="c13">scope</span><span class="c3">, all contributions to that scope are aggregated into the final graph implementation in code gen.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>If a graph supports multiple scopes, use </span><span class="c13">additionalScopes</span><span class="c3">.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph(<br> &nbsp;AppScope::class,<br> &nbsp;additionalScopes = [LoggedOutScope::class]<br>)</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>Similar to </span><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/amzn/kotlin-inject-anvil&amp;sa=D&amp;source=editors&amp;ust=1762461866478075&amp;usg=AOvVaw18DpqqSClG5b6JPmtbsKOL">kotlin-inject-anvil</a></span><span>, </span><span class="c13">@DependencyGraph</span><span class="c3">&nbsp;supports excluding contributions by class. This is useful for cases like tests, where you may want to contribute a test/fake implementation that supersedes the &ldquo;real&rdquo; graph.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph(<br> &nbsp;scope = AppScope::class,<br> &nbsp;</span><span class="c4">excludes = [RealNetworkProviders::class]</span><sup><a href="#cmnt154" id="cmnt_ref154">[ex]</a></sup><sup><a href="#cmnt155" id="cmnt_ref155">[ey]</a></sup><sup><a href="#cmnt156" id="cmnt_ref156">[ez]</a></sup><sup><a href="#cmnt157" id="cmnt_ref157">[fa]</a></sup><sup><a href="#cmnt158" id="cmnt_ref158">[fb]</a></sup><sup><a href="#cmnt159" id="cmnt_ref159">[fc]</a></sup><sup><a href="#cmnt160" id="cmnt_ref160">[fd]</a></sup><span class="c4"><br>)</span><span class="c12"><br>interface </span><span class="c21">TestAppGraph</span><span class="c12"><br><br></span><span class="c4">@ContributesTo(AppScope::class)</span><span class="c12"><br>interface </span><span class="c21">TestNetworkProviders</span><span class="c12">&nbsp;{<br> &nbsp;</span><span class="c4">@Provides</span><span class="c12">&nbsp;fun </span><span class="c9">provideHttpClient</span><span class="c12">(): TestHttpClient<br>}</span></p></td></tr></table><h4 class="c1" id="h.5pqxfk8jb77c"><span class="c18">@ContributesTo</span></h4><p class="c22"><span class="c3">This annotation is used to contribute graph interfaces to the target scope to be merged in at graph-processing time to the final merged graph class as another supertype.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@ContributesTo(AppScope::class)</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">NetworkProviders</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c4">@Provides</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideHttpClient</span><span class="c8">(): HttpClient<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span>This annotation is </span><span class="c30">repeatable</span><span class="c3">&nbsp;and can be used to contribute to multiple scopes.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c23 c4">@ContributesTo(AppScope::class)</span></p><p class="c35"><span class="c4">@ContributesTo(LoggedInScope::class)</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">NetworkProviders</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c4">@Provides</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideHttpClient</span><span class="c8">(): HttpClient<br>}</span></p></td></tr></table><h4 class="c1" id="h.iuua5ixmwz73"><span class="c18">@ContributesBinding</span></h4><p class="c22"><span class="c3">This annotation is used to contribute injected classes to a target scope as a given bound type.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>The below example will contribute the </span><span class="c13">CacheImpl</span><span>&nbsp;class as a </span><span class="c13">Cache</span><span>&nbsp;type to </span><span class="c13">AppScope</span><span class="c3">.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@</span><span class="c4">ContributesBinding</span><sup><a href="#cmnt161" id="cmnt_ref161">[fe]</a></sup><sup><a href="#cmnt162" id="cmnt_ref162">[ff]</a></sup><span class="c4">(AppScope::class)</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">CacheImpl</span><span class="c8">(...) : Cache</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">For simple cases where there is a single typertype, that type is implicitly used as the bound type. If your bound type is qualified, for the implicit case you can put the qualifier on the class.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@Named(&quot;cache&quot;)</span><span class="c8"><br></span><span class="c4">@ContributesBinding(AppScope::class)</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">CacheImpl</span><span class="c8">(...) : Cache</span></p></td></tr></table><p class="c22"><span>For classes with multiple supertypes or advanced cases where you want to bind an ancestor type, you can explicitly define this via </span><span class="c13">boundType</span><span class="c3">&nbsp;parameter.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@ContributesBinding(<br> &nbsp;scope = AppScope::class,<br> &nbsp;boundType = BoundType&lt;Cache&gt;()</span><span class="c8"><br>)<br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">CacheImpl</span><span class="c8">(...) : Cache, AnotherType</span></p></td></tr></table><p class="c22"><span>Note that the bound type is defined as the type argument to </span><span class="c13">@ContributesBinding</span><span class="c3">. This allows for the bound type to be generic and is validated in FIR.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>Qualifier annotations can be specified on the </span><span class="c13">BoundType</span><span class="c3">&nbsp;type parameter and will take precedence over any qualifiers on the class itself.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@ContributesBinding(<br> &nbsp;scope = AppScope::class,<br> &nbsp;boundType = BoundType&lt;@Named(&quot;cache&quot;)</span><span class="c8">&nbsp;Cache&gt;()<br>)<br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">CacheImpl</span><span class="c8">(...) : Cache, AnotherType</span></p></td></tr></table><p class="c22"><span>This annotation is </span><span class="c30">repeatable</span><span class="c3">&nbsp;and can be used to contribute to multiple scopes.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@ContributesBinding(<br> &nbsp;scope = AppScope::class,<br> &nbsp;boundType = BoundType&lt;Cache&gt;()</span><span class="c8"><br>)<br></span><span class="c4">@ContributesBinding(<br> &nbsp;scope = AppScope::class,<br> &nbsp;boundType = BoundType&lt;AnotherType&gt;()</span><span class="c8"><br>)<br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">CacheImpl</span><span class="c8">(...) : Cache, AnotherType</span></p></td></tr></table><h4 class="c1" id="h.ygclg71uf2hk"><span class="c18">@ContributesIntoSet/@ContributesIntoMap</span></h4><p class="c5"><span class="c3"></span></p><p class="c22"><span>To contribute into a multibinding, use the </span><span class="c13">@ContributesIntoSet</span><span>&nbsp;or </span><span class="c13">@ContributesIntoMap</span><span class="c3">&nbsp;annotations as needed.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@ContributesIntoSet(AppScope::class)</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">CacheImpl</span><span class="c8 c23">(...) : Cache</span></p></td></tr></table><p class="c22"><span>Same rules around qualifiers and </span><span class="c13">boundType()</span><span>&nbsp;apply in this scenario</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>To contribute </span><span>into</span><span>&nbsp;a Map multibinding, the map key annotation must be specified on the class or </span><span class="c13">BoundType</span><span>&nbsp;type argument</span><span class="c3">.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c20">// Will be contributed into a Map multibinding with ClassKey(</span><span class="c8"><br></span><span class="c4">@ContributesIntoMap(AppScope::class)</span><span class="c8"><br></span><span class="c4">@StringKey(&quot;Networking&quot;)</span><span class="c8"><br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">CacheImpl</span><span class="c8">(...) : Cache<br><br></span><span class="c20">// Or if using BoundType</span><span class="c8"><br></span><span class="c4">@ContributesIntoMap(<br> &nbsp;scope = AppScope::class,<br> &nbsp;boundType = BoundType&lt;@StringKey(&quot;Networking&quot;)</span><span class="c8">&nbsp;Cache&gt;()<br>)<br></span><span class="c4">@Inject</span><span class="c8"><br></span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">CacheImpl</span><span class="c8 c23">(...) : Cache</span></p></td></tr></table><p class="c22"><span class="c3">This annotation is also repeatable and can be used to contribute to multiple scopes, multiple bound types, and multiple map keys.</span></p><p class="c5"><span class="c3"></span></p><p class="c5"><span class="c23 c13"></span></p><p class="c22"><span class="c13">@GraphExtension</span></p><p class="c22"><span>TODO, but TL;DR works the same a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s kotlin-inject-anvil&rsquo;s </span><span class="c13">@ContributesSubcomponent</span><span>.</span><sup><a href="#cmnt163" id="cmnt_ref163">[fg]</a></sup><sup><a href="#cmnt164" id="cmnt_ref164">[fh]</a></sup></p><h4 class="c1" id="h.bbaadfqcr5n8"><span class="c18">Implementation notes</span></h4><p class="c22"><span class="c3">This leans on Kotlin&rsquo;s ability to put generic type parameters on annotations. That in turn allows for both generic bound types and to contribute map bindings to multiple map keys.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Because it&rsquo;s a first-party feature, there&rsquo;s no need for intermediary &ldquo;merged&rdquo; components like kotlin-inject-anvil and anvil-ksp do.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>Generated contributing interfaces are generated to the </span><span class="c13">metro.hints</span><span>&nbsp;package and located during graph supertype generation in FIR downstream. Any contributed bindings are implemented as </span><span class="c13">@Binds</span><span class="c3">&nbsp;(&plusmn; IntoSet/IntoMap/etc) annotated properties.</span></p><h3 class="c39" id="h.fpryour8w74o"><span class="c14">Multiplatform</span></h3><p class="c22"><span>Should Just </span><span>Work&trade;&#65039; but</span><span class="c3">&nbsp;will see when we get there! The runtime and code gen have been implemented to be entirely platform-agnostic so far.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">There is one issue in the repo right now where the compiler appears to have a bug with generated FIR declarations where it doesn&rsquo;t deserialize them correctly on non-JVM targets. Waiting for feedback from JB.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>When mixing contributions between common and platform-specific source sets, you must define your final </span><span class="c13">@DependencyGraph</span><span>&nbsp;in the platform-specific code. This is because a graph defined in commonMain wouldn&rsquo;t have full visibility of contributions from platform-specific types. A good pattern for this is to define your canonical graph in commonMain </span><span class="c30">without</span><span>&nbsp;a </span><span class="c13">@DependencyGraph</span><span>&nbsp;annotation and then a </span><span class="c13">{Platform}{Graph}</span><span>&nbsp;type in the platform source set that extends it and does have the </span><span class="c13">@DependencyGraph</span><span class="c3">. Metro automatically exposes bindings of the base graph type on the graph for any injections that need it.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c20">// In commonMain</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AppGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;httpClient: HttpClient<br>}<br><br></span><span class="c20">// In jvmMain</span><span class="c8"><br></span><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">JvmAppGraph</span><span class="c8">&nbsp;: </span><span class="c21">AppGraph {</span><span class="c8"><br> &nbsp;</span><span class="c4">@Provides</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideHttpClient</span><span class="c8">(): HttpClient = HttpClient(Netty)<br>}<br><br></span><span class="c20">// In androidMain</span><span class="c8"><br></span><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">AndroidAppGraph</span><span class="c8">&nbsp;: </span><span class="c21">AppGraph {</span><span class="c8"><br> &nbsp;</span><span class="c4">@Provides</span><span class="c8">&nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">provideHttpClient</span><span class="c8">(): HttpClient = HttpClient(OkHttp)<br>}</span></p></td></tr></table><h3 class="c39" id="h.olzzvebkql6b"><span class="c14">Validation and Error Reporting</span></h3><p class="c22"><span class="c3">Common programmer/usage errors are implemented in FIR. This should allow errors to appear directly in the IDE, offering the best and fastest feedback loop for developers writing their code.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">TODO IDE screenshot example</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Dependency graph validation is performed at the per-graph level. Metro seeks to report binding validation errors at least on par with Dagger, if not better.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c8">ExampleGraph.kt:</span><span class="c28">6</span><span class="c8">:</span><span class="c28">1</span><span class="c8">&nbsp;[Metro/DependencyCycle] Found a dependency cycle:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kotlin.</span><span class="c31">Int</span><span class="c8">&nbsp;</span><span class="c12">is</span><span class="c8">&nbsp;injected at<br> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[test.ExampleGraph] test.ExampleGraph.provideString(..., int)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kotlin.String </span><span class="c12">is</span><span class="c8">&nbsp;injected at<br> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[test.ExampleGraph] test.ExampleGraph.provideDouble(..., string)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kotlin.</span><span class="c31">Double</span><span class="c8">&nbsp;</span><span class="c12">is</span><span class="c8">&nbsp;injected at<br> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[test.ExampleGraph] test.ExampleGraph.provideInt(..., double)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kotlin.</span><span class="c31">Int</span><span class="c8">&nbsp;</span><span class="c12">is</span><span class="c8">&nbsp;injected at<br> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[test.ExampleGraph] test.ExampleGraph.provideString(..., int)</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Binding errors take learnings from Dagger and report fully qualified references that IDEs like IntelliJ can usually autolink.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c8">ExampleGraph.kt:</span><span class="c28">6</span><span class="c8">:</span><span class="c28">1</span><span class="c8">&nbsp;[Metro/GraphDependencyCycle] Dependency graph dependency cycle detected! The below graph depends on itself.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.CharSequenceGraph </span><span class="c12">is</span><span class="c8">&nbsp;requested at<br> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[test.CharSequenceGraph] test.CharSequenceGraph.Factory.create()</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Note that binding graph resolution currently only happens in the compiler IR backend, but maybe someday we can move this to FIR to get errors in the IDE.</span></p><p class="c5"><span class="c3"></span></p><h3 class="c39" id="h.xrmytua4ptu4"><span class="c14">Interop</span></h3><h4 class="c1" id="h.222nhtelxabl"><span class="c18">Annotations</span></h4><p class="c22"><span class="c3">Metro supports user-defined annotations for common annotations. This means that a user doesn&rsquo;t necessarily have to use Metro&rsquo;s annotations if they&rsquo;re introducing it to an existing codebase. Support varies depending on the annotation&rsquo;s use case.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Compile-only annotations are mostly supported. This includes the following:</span></p><ul class="c19 lst-kix_insgc4ut8xxf-0 start"><li class="c7 li-bullet-0"><span class="c13">@Assisted</span></li><li class="c7 li-bullet-0"><span class="c13">@AssistedFactory</span></li><li class="c7 li-bullet-0"><span class="c13">@AssistedInject</span></li><li class="c7 li-bullet-0"><span class="c13">@Binds</span></li><li class="c7 li-bullet-0"><span class="c13">@BindsInstance</span></li><li class="c7 li-bullet-0"><span class="c13">@ContributesTo</span></li><li class="c7 li-bullet-0"><span class="c13">@ContributesBinding</span></li><li class="c7 li-bullet-0"><span class="c13">@ElementsIntoSet</span></li><li class="c7 li-bullet-0"><span class="c13">@DependencyGraph</span></li><li class="c7 li-bullet-0"><span class="c13">@DependencyGraph.Factory</span></li><li class="c7 li-bullet-0"><span class="c13">@Inject</span></li><li class="c7 li-bullet-0"><span class="c13">@IntoMap</span></li><li class="c7 li-bullet-0"><span class="c13">@IntoSet</span></li><li class="c7 li-bullet-0"><span class="c13">@MapKey</span></li><li class="c7 li-bullet-0"><span class="c13">@Multibinds</span></li><li class="c7 li-bullet-0"><span class="c13">@Provides</span></li><li class="c7 li-bullet-0"><span class="c13">@Qualifier</span></li><li class="c7 li-bullet-0"><span class="c13">@Scope</span></li></ul><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">These are configurable via Metro&rsquo;s Gradle extension.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c8">metro {<br> &nbsp;</span><span class="c8">customAnnotations</span><sup><a href="#cmnt165" id="cmnt_ref165">[fi]</a></sup><sup><a href="#cmnt166" id="cmnt_ref166">[fj]</a></sup><span class="c8">&nbsp;{<br> &nbsp; &nbsp;assisted.add(</span><span class="c34">&quot;dagger/assisted/Assisted&quot;</span><span class="c8">)<br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">For Dagger and KI specifically, there are convenience helper functions.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c8 c23">metro {<br> &nbsp;customAnnotations {<br> &nbsp; &nbsp;includeDagger()<br> &nbsp; &nbsp;includeKotlinInject()</span></p><p class="c35"><span class="c8">&nbsp; &nbsp; includeAnvil()<br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c13">@DependencyGraph</span><span>&nbsp;is replaceable but your mileage may vary if you use Anvil or modules, since Metro&rsquo;s annotation unifies Anvil&rsquo;s </span><span class="c13">@MergeComponent</span><span class="c3">&nbsp;functionality and doesn&rsquo;t support modules.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>Similarly, </span><span class="c13">@ContributesBinding</span><span>&nbsp;is replaceable but there are not direct analogues for Anvil&rsquo;s </span><span class="c13">@ContributesMultibinding</span><span>&nbsp;or kotlin-inject-anvil&rsquo;s </span><span class="c13">@ContributesBinding(multibinding = &hellip;)</span><span>&nbsp;as these annotations are implemented as </span><span class="c13">@ContributesInto*</span><span>&nbsp;annotations in Metro. Also - </span><span class="c13">boundType</span><span>&nbsp;in metro uses a more flexible mechanism to support generics.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>Intrinsics like </span><span class="c13">Provider</span><span>&nbsp;and </span><span class="c13">Lazy</span><span>&nbsp;are not supported because their semantics are slightly different. However, we could look into this in the future as integration artifacts that offer composite implementations (similar to how Dagger&rsquo;s internal </span><span class="c13">Provider</span><span>&nbsp;implements both </span><span class="c13">javax.inject.Provider</span><span>&nbsp;and </span><span class="c13">jakarta.inject.Provider</span><span>&nbsp;now).</span></p><p class="c5"><span class="c3"></span></p><h4 class="c1" id="h.uf4x441b55ft"><span class="c18">Components</span></h4><p class="c22"><span class="c3">Metro graphs can interop with components generated by Dagger and Kotlin-Inject. These work exclusively through their public accessors and can be depended on like any other graph dependency.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">MetroGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br><br> &nbsp;</span><span class="c4">@DependencyGraph</span><span class="c8">.Factory<br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;interface Factory {<br> &nbsp; &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">create</span><span class="c8">(<br> &nbsp; &nbsp; &nbsp;daggerComponent: </span><span class="c21">DaggerComponent</span><span class="c8"><br> &nbsp; &nbsp;): MetroGraph<br> &nbsp;}<br>}<br><br></span><span class="c4">@dagger</span><span class="c8">.Component<br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">DaggerComponent</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br><br> &nbsp;</span><span class="c4">@dagger</span><span class="c8">.Component.Factory<br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;interface Factory {<br> &nbsp; &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">create</span><span class="c8">(</span><span class="c4">@Provides</span><span class="c8">&nbsp;message: </span><span class="c21">String</span><span class="c8">): DaggerComponent<br> &nbsp;}<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">Conversely, kotlin-inject and Dagger components can also depend on Metro graphs.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c4">@DependencyGraph</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">MessageGraph</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br><br> &nbsp;</span><span class="c20">// ...</span><span class="c8"><br>}<br><br></span><span class="c20">// Dagger</span><span class="c8"><br></span><span class="c4">@Component(dependencies = [MetroGraph::class])</span><span class="c8"><br></span><span class="c12">interface</span><span class="c8">&nbsp;</span><span class="c21">DaggerComponent</span><span class="c8">&nbsp;{<br> &nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;message: String<br><br> &nbsp;</span><span class="c4">@Component</span><span class="c8">.Factory<br> &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;interface Factory {<br> &nbsp; &nbsp;</span><span class="c12">fun</span><span class="c8">&nbsp;</span><span class="c9">create</span><span class="c8">(messageGraph: </span><span class="c21">MessageGraph</span><span class="c8">): DaggerComponent<br> &nbsp;}<br>}<br><br></span><span class="c20">// kotlin-inject</span><span class="c8"><br></span><span class="c4">@Component</span><span class="c8"><br>Abstract </span><span class="c12">class</span><span class="c8">&nbsp;</span><span class="c21">KotlinInjectComponent</span><span class="c8">(<br> &nbsp;</span><span class="c4">@Component</span><span class="c8">&nbsp;</span><span class="c12">val</span><span class="c8">&nbsp;messageGraph: MessageGraph<br>) {<br> &nbsp;</span><span class="c12">val</span><span class="c8 c23">&nbsp;message: String<br>}</span></p></td></tr></table><h3 class="c39" id="h.tvzuk5ryd5sb"><span class="c14">Generating Metro code</span></h3><p class="c22"><span>Java annotation processing and KSP both support multiple rounds of processing, allowing custom processors to generate new code with injection annotations that can be processed in later rounds. Anvil supported custom </span><span class="c13">CodeGenerator</span><span class="c3">&nbsp;implementations in K1 and anvil-ksp and kotlin-inject-anvil support specifying custom contributing annotations to allow them to intelligently defer processing to later rounds.</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>Since Metro is implemented as a compiler plugin, asking users to write compiler plugins to interact with it would be a bit unwieldy. </span><span>However, KSP processors that generate metro-annotated code work out of the box with it since they run before Metro&rsquo;s plugin does.</span><sup><a href="#cmnt167" id="cmnt_ref167">[fk]</a></sup><sup><a href="#cmnt168" id="cmnt_ref168">[fl]</a></sup></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>If you have an existing KSP processor for a different framework, you could leverage it + custom annotations interop support described above to make them work out of the box with Metro.</span></p><hr><h1 class="c27 c36" id="h.vkxa2nbk3aj8"><span class="c33"></span></h1><h1 class="c27" id="h.69uzdqlviz4h"><span class="c33">Debugging</span></h1><p class="c22"><span class="c3">One major downside to generating IR directly is that developers cannot step into generated source code with the debugger. This is an accepted trade-off with Metro (or any other compiler plugin).</span></p><p class="c5"><span class="c3"></span></p><p class="c22"><span>Metro does offer a </span><span class="c13">debug</span><span class="c3">&nbsp;option in its plugin options/Gradle extension that will print verbose Kotlin pseudocode for all generated IR classes. This can be further tuned to print just certain classes.</span></p><p class="c5"><span class="c3"></span></p><table class="c6"><tr class="c16"><td class="c17" colspan="1" rowspan="1"><p class="c35"><span class="c8">metro {<br> &nbsp;debug.</span><span class="c12">set</span><span class="c8">(</span><span class="c28">true</span><span class="c8">)<br>}</span></p></td></tr></table><p class="c5"><span class="c3"></span></p><p class="c22"><span class="c3">In the future, we could possibly explore including information in IR to synthesize call stack information similar to coroutines, but will save that for if/when it&rsquo;s asked for.</span></p><p class="c5"><span class="c3"></span></p><hr><p class="c5"><span class="c3"></span></p><h1 class="c27" id="h.z3u4bc9ifopj"><span class="c33">Open Questions</span></h1><ul class="c19 lst-kix_oq7so7y4wkm1-0 start"><li class="c7 li-bullet-0"><span class="c3">&#9989;Should we rename Lattice ==&gt; ???</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">Metro!</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-0"><li class="c7 li-bullet-0"><span class="c3">&#9989;Should we rename Component -&gt; ObjectGraph? DependencyGraph?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1 start"><li class="c22 c24 li-bullet-0"><span>Making a call: </span><span class="c13">@DependencyGraph</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-0"><li class="c7 li-bullet-0"><span class="c3">How should nullability work?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">First class citizen of type keys? I.e. allow String and String? as distinct keys</span></li><li class="c22 c24 li-bullet-0"><span>Allow assignability? I.e. can request String? and provide String?, but requesting String and only providing String? is a missing binding?</span><sup><a href="#cmnt169" id="cmnt_ref169">[fm]</a></sup><sup><a href="#cmnt170" id="cmnt_ref170">[fn]</a></sup><sup><a href="#cmnt171" id="cmnt_ref171">[fo]</a></sup><sup><a href="#cmnt172" id="cmnt_ref172">[fp]</a></sup><sup><a href="#cmnt173" id="cmnt_ref173">[fq]</a></sup><sup><a href="#cmnt174" id="cmnt_ref174">[fr]</a></sup><sup><a href="#cmnt175" id="cmnt_ref175">[fs]</a></sup><sup><a href="#cmnt176" id="cmnt_ref176">[ft]</a></sup></li><li class="c22 c24 li-bullet-0"><span class="c3">Just a special form of an optional binding? If string is present it&rsquo;s used, if it&rsquo;s not then null? </span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-0"><li class="c7 li-bullet-0"><span class="c3">How should typealiases be treated?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1 start"><li class="c22 c24 li-bullet-0"><span>These are used in Kotlin Inject for both implicit qualifiers as well as </span><span>linking top-level injected functions to recognizable binding types.</span><sup><a href="#cmnt177" id="cmnt_ref177">[fu]</a></sup><sup><a href="#cmnt178" id="cmnt_ref178">[fv]</a></sup><sup><a href="#cmnt179" id="cmnt_ref179">[fw]</a></sup></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-0"><li class="c7 li-bullet-0"><span class="c3">How much time should we spend looking into moving graph validation into FIR? Concerns are:</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">The most compelling use cases for this are</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-2 start"><li class="c2 li-bullet-0"><span class="c3">Directly linking/adding contributed interfaces, which FIR has a hook for adding to.</span></li><li class="c2 li-bullet-0"><span class="c3">Showing validation errors as early as possible.</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1"><li class="c22 c24 li-bullet-0"><span class="c3">Is there a performance concern in this? I.e. doing expensive validation in the IDE, often multiple times</span></li><li class="c22 c24 li-bullet-0"><span class="c3">Do we want generated factories/graphs/etc to be visible? This comes with FIR-generated types.</span></li><li class="c22 c24 li-bullet-0"><span class="c3">How do you plumb that information over to IR when generating in a way that avoids duplicating logic/time recomputing the graph in IR?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-2 start"><li class="c2 li-bullet-0"><span>If we can generate enough information in FIR code headers then maybe we can avoid recomputing.</span><sup><a href="#cmnt180" id="cmnt_ref180">[fx]</a></sup></li><li class="c2 li-bullet-0"><span class="c3">Otherwise we need to pass on/serialize this information somehow.</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1"><li class="c22 c24 li-bullet-0"><span class="c3">How do you report errors on places that are not visible in the editor? For example: a graph may expose an accessor to a class that it can&rsquo;t fulfill, but the binding error is on that class&rsquo;s inject constructor.</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-0"><li class="c7 li-bullet-0"><span class="c3">&#9989;Any strong opinions on not supporting constructor properties in graphs?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">Call: Not supporting</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-0"><li class="c7 li-bullet-0"><span class="c3">Are there other desirable areas of interop that should be investigated?</span></li><li class="c7 li-bullet-0"><span class="c3">Are there other kotlin language/stdlib features we should support?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1 start"><li class="c22 c24 li-bullet-0"><span>Make graphs implement </span><span class="c13">CoroutineScope</span><span>? Make them cancellable?</span><sup><a href="#cmnt181" id="cmnt_ref181">[fy]</a></sup><sup><a href="#cmnt182" id="cmnt_ref182">[fz]</a></sup><sup><a href="#cmnt183" id="cmnt_ref183">[ga]</a></sup><sup><a href="#cmnt184" id="cmnt_ref184">[gb]</a></sup><sup><a href="#cmnt185" id="cmnt_ref185">[gc]</a></sup><sup><a href="#cmnt186" id="cmnt_ref186">[gd]</a></sup><sup><a href="#cmnt187" id="cmnt_ref187">[ge]</a></sup><sup><a href="#cmnt188" id="cmnt_ref188">[gf]</a></sup><sup><a href="#cmnt189" id="cmnt_ref189">[gg]</a></sup><sup><a href="#cmnt190" id="cmnt_ref190">[gh]</a></sup><sup><a href="#cmnt191" id="cmnt_ref191">[gi]</a></sup></li><li class="c22 c24 li-bullet-0"><span class="c3">What about upcoming features?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-2 start"><li class="c2 li-bullet-0"><span class="c3">Context parameters?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-0"><li class="c7 li-bullet-0"><span class="c3">What other features should we support?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1 start"><li class="c22 c24 li-bullet-0"><span>Dump dependency graph</span><sup><a href="#cmnt192" id="cmnt_ref192">[gj]</a></sup><span>?</span><sup><a href="#cmnt193" id="cmnt_ref193">[gk]</a></sup></li><li class="c22 c24 li-bullet-0"><span>SPI integration</span><sup><a href="#cmnt194" id="cmnt_ref194">[gl]</a></sup><span class="c3">?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-0"><li class="c7 li-bullet-0"><span>&#9989;Rename &ldquo;binds&rdquo; semantics to &ldquo;aliased providers&rdquo; or something else? Since there is no </span><span class="c13">@Binds</span><span class="c3">.</span></li><li class="c7 li-bullet-0"><span>Do map contributors need to have </span><span class="c13">@IntoMap</span><span>&nbsp;</span><span class="c30">and</span><span>&nbsp;a map key?</span><sup><a href="#cmnt195" id="cmnt_ref195">[gm]</a></sup><sup><a href="#cmnt196" id="cmnt_ref196">[gn]</a></sup><sup><a href="#cmnt197" id="cmnt_ref197">[go]</a></sup><sup><a href="#cmnt198" id="cmnt_ref198">[gp]</a></sup></li><li class="c7 li-bullet-0"><span class="c3">What are extension points we wish Kotlin had to improve the overall design?</span></li></ul><ul class="c19 lst-kix_oq7so7y4wkm1-1 start"><li class="c22 c24 li-bullet-0"><span>FIR extension for not requiring function/property bodies =&gt; graphs wouldn&rsquo;t need to be an interface, but could also be a regular class. The compiler plugin could fill in the body via IR.</span><sup><a href="#cmnt199" id="cmnt_ref199">[gq]</a></sup><sup><a href="#cmnt200" id="cmnt_ref200">[gr]</a></sup></li></ul><p class="c5"><span class="c3"></span></p><p class="c5"><span class="c3"></span></p><h3 class="c39" id="h.94d1cdgkf9h7"><span>Questions from design doc discussion</span></h3><ul class="c19 lst-kix_oq7so7y4wkm1-0"><li class="c7 li-bullet-0"><span>Should we generate one implicit </span><span class="c13">@AssistedFactory</span><span>&nbsp;type with FIR? Can still support custom ones via just adding a function to an interface?</span></li></ul><p class="c5"><span class="c3"></span></p><h1 class="c27" id="h.su6uogn72vnh"><span class="c33">Design Doc Changelog</span></h1><p class="c22"><span class="c3">List of decisions/changes made based on design doc feedback</span></p><ul class="c19 lst-kix_84t52pnfef3b-0 start"><li class="c7 li-bullet-0"><span class="c3">&#9989; Support 0..n scopes on graphs</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-1 start"><li class="c22 c24 li-bullet-0"><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/ZacSweers/lattice/pull/55&amp;sa=D&amp;source=editors&amp;ust=1762461866503010&amp;usg=AOvVaw2JHEFRgn3Va62bgVZQaKMj">https://github.com/ZacSweers/metro/pull/55</a></span><span>&nbsp;</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-0"><li class="c7 li-bullet-0"><span>&#9989;Support generating one implicit </span><span class="c13">@AssistedFactory</span><span class="c3">&nbsp;type with FIR. Custom declarations are still supported.</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-1 start"><li class="c22 c24 li-bullet-0"><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/ZacSweers/lattice/pull/60&amp;sa=D&amp;source=editors&amp;ust=1762461866503348&amp;usg=AOvVaw0W9kloiTCOdWle-P41XhFC">https://github.com/ZacSweers/metro/pull/60</a></span><span>&nbsp;</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-0"><li class="c7 li-bullet-0"><span>&#128679;Require providers to be </span><span class="c23 c13">private</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-1 start"><li class="c22 c24 li-bullet-0"><span class="c3">Requires Kotlin 2.1.20 to be fully supported across modules</span></li><li class="c22 c24 li-bullet-0"><span>Partially implemented an automatic status transformer in </span><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/ZacSweers/lattice/pull/94&amp;sa=D&amp;source=editors&amp;ust=1762461866503689&amp;usg=AOvVaw1oNTnHTSgYcOLa1wIjUYzQ">https://github.com/ZacSweers/metro/pull/94</a></span><span>&nbsp;</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-0"><li class="c7 li-bullet-0"><span>Support Anvil </span><span class="c23 c13">replaces</span></li><li class="c7 li-bullet-0"><span>&#9989;Disallow provider overrides in favor of </span><span class="c13">replaces</span><span>/</span><span class="c23 c13">excludes</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-1 start"><li class="c22 c24 li-bullet-0"><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/ZacSweers/lattice/pull/72&amp;sa=D&amp;source=editors&amp;ust=1762461866504007&amp;usg=AOvVaw0OLyhQWP1oa-lNdyk466h9">https://github.com/ZacSweers/metro/pull/72</a></span><span class="c3">&nbsp;</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-0"><li class="c7 li-bullet-0"><span>Move </span><span class="c13">@Singleton</span><span class="c3">&nbsp;to a separate, optional/compat runtime artifact.</span></li><li class="c7 li-bullet-0"><span>&#9989;Reintroduce </span><span class="c23 c13">@Binds</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-1 start"><li class="c22 c24 li-bullet-0"><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/ZacSweers/lattice/pull/89&amp;sa=D&amp;source=editors&amp;ust=1762461866504320&amp;usg=AOvVaw1BoGs6hMKjhLHRX9ELUkbn">https://github.com/ZacSweers/metro/pull/89</a></span><span class="c3">&nbsp;</span></li><li class="c22 c24 li-bullet-0"><span>&#128683;Reuse </span><span class="c13">@Provides</span><span class="c3">&nbsp;for binds providers</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-2 start"><li class="c2 li-bullet-0"><span>Initially implemented with </span><span class="c13">@Provides</span><span>&nbsp;in </span><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/ZacSweers/lattice/pull/56&amp;sa=D&amp;source=editors&amp;ust=1762461866504580&amp;usg=AOvVaw24HS27VzDyunIVPltsxHqt">https://github.com/ZacSweers/metro/pull/56</a></span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-0"><li class="c7 li-bullet-0"><span>&#9989;Remove </span><span class="c13">@AssistedInject</span><span>&nbsp;in favor of just using </span><span class="c13">@Inject</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-1 start"><li class="c22 c24 li-bullet-0"><span class="c40"><a class="c41" href="https://www.google.com/url?q=https://github.com/ZacSweers/lattice/pull/96&amp;sa=D&amp;source=editors&amp;ust=1762461866504820&amp;usg=AOvVaw09oSp3Yc11Ij4UjFww7e5Q">https://github.com/ZacSweers/metro/pull/96</a></span><span class="c3">&nbsp;</span></li></ul><ul class="c19 lst-kix_84t52pnfef3b-0"><li class="c7 li-bullet-0"><span>&#9989;Use </span><span class="c13">@ContributesIntoSet</span><span>/</span><span class="c13">@ContributesIntoMap</span><span class="c3">&nbsp;annotations</span></li><li class="c7 li-bullet-0"><span>&#9989;Remove </span><span class="c13">@BindsInstance</span><span>&nbsp;in favor of reusing </span><span class="c13">@Provides</span></li></ul><div class="c10"><p class="c0"><a href="#cmnt_ref1" id="cmnt1">[a]</a><span class="c3">i think this may be a common thought. suggest moving it up below the overview</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref2" id="cmnt2">[b]</a><span class="c3">Fair!</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref3" id="cmnt3">[c]</a><span class="c3">Moving up</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref4" id="cmnt4">[d]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref5" id="cmnt5">[e]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref6" id="cmnt6">[f]</a><span class="c3">Note to self - wanna reword this better. Want to make it clear the goal is unification of best ideas and explicitly builds off of what they do well + borrows generously.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref7" id="cmnt7">[g]</a><span class="c3">how does this affect the maintenance story? kotlin updates are already tough enough w/ compose, ksp, &amp; other core kotlin libraries</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref8" id="cmnt8">[h]</a><span class="c3">Same as basically any other compiler plugin unfortunately. Some releases will need need companion releases of Lattice to work with them. That said, I have a pretty good track record with existing plugins and could add a explicit commitment around releasing with EAP releases of Kotlin.</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">James Barr reacted with &#128077; at 2024-12-30 20:12 PM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref9" id="cmnt9">[i]</a><span class="c3">@Binds? @BindsInstance?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref10" id="cmnt10">[j]</a><span class="c3">Lattice has both! This is just differences</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref11" id="cmnt11">[k]</a><span class="c3">I was hoping it wouldn&#39;t have them. Discussed below that I find them redundant. I&#39;ll resolve this conversation.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref12" id="cmnt12">[l]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref13" id="cmnt13">[m]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref14" id="cmnt14">[n]</a><span class="c3">not that important but this is a holdover from the KAPT implementation, do plan to get rid of it</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref15" id="cmnt15">[o]</a><span class="c3">ahh good to know</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref16" id="cmnt16">[p]</a><span class="c3">not saying you need to support this first party, but please consider that any core logic is pushed down into a core module not tied to gradle so other build systems can hook this up, too</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref17" id="cmnt17">[q]</a><span class="c3">yep it works fine with other plugins, the gradle plugin is a thin shim just for how plugins are normally applied. Added a mention for other build systems below it when I saw you highlight this :)</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">James Barr reacted with &#128518; at 2024-12-30 20:10 PM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref18" id="cmnt18">[r]</a><span class="c3">Added a bazel sample snippet!</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref19" id="cmnt19">[s]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref20" id="cmnt20">[t]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref21" id="cmnt21">[u]</a><span class="c3">Curious why you landed on this name? Find it super interesting you are moving away from &#39;Component&#39;</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref22" id="cmnt22">[v]</a><span class="c3">I&#39;ve always found dagger&#39;s names for some things to be a bit vague and sometimes too overloaded, so one of the goals is to use more obvious names where it made sense.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">&quot;Component&quot; and &quot;Module&quot; in particular really run up against it if you&#39;re also working in a gradle project, or heck even with Module you conflict with java.lang&#39;s own Module type &#128517;.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">This name floated to the top of a few ideas. When this was still called lattice, `@Lattice` was an option. `@Graph`, `@Dependencies`, `@Scope`, `@BindingGraph`, and some others were in the picture. This felt the most natural and also lends itself well to naming annotated types with it (i.e. &quot;AppGraph&quot;). It also lent itself well to the later `@GraphExtension` concept later as a replacement for `@ContributesSubcomponent`/`@Subcomponent`.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref23" id="cmnt23">[w]</a><span class="c3">&#128077;&#127995;</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref24" id="cmnt24">[x]</a><span class="c3">I&#39;d like to have a solution where `@Provides` functions aren&#39;t manually callable and you can only use properties to extract objects from the graph.</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">Daniel Santiago reacted with &#10133; at 2024-12-17 19:43 PM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref25" id="cmnt25">[y]</a><span class="c3">Something I&#39;ve been thinking about after working on optional bindings is that now that lattice generates factories as nested classes of their parent interface directly, it also means they can call private functions and we can just mark providers as all private. With FIR we can even require it. How does that sound?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref26" id="cmnt26">[z]</a><span class="c3">Confirmed and implemented this in the FIR checker now. Plan to make this a configurable warning (i.e. so migrations can be done incrementally)</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref27" id="cmnt27">[aa]</a><span class="c3">Using `FirStatusTransformerExtension`, you could make this conversion to private automatic if you would like. Sort of like all-open but in reverse. See&nbsp;https://github.com/JetBrains/kotlin/blob/master/plugins/plugin-sandbox/src/org/jetbrains/kotlin/plugin/sandbox/fir/AllOpenStatusTransformer.kt as an example.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref28" id="cmnt28">[ab]</a><span class="c3">Nice! Do you know how that would appear in the IDE by chance? Filed this to track https://github.com/ZacSweers/lattice/issues/53</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref29" id="cmnt29">[ac]</a><span class="c3">Piecemeal does this on constructors:&nbsp;https://github.com/bnorm/piecemeal/blob/main/piecemeal-plugin/src/main/kotlin/dev/bnorm/piecemeal/plugin/fir/PiecemealFirStatusTransformerExtension.kt</span></p><p class="c0"><span class="c3">Shows up as an INVISIBLE_REFERENCE error in the IDE with K2 mode enabled .</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">Zac Sweers reacted with &#128640; at 2024-12-19 07:20 AM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref30" id="cmnt30">[ad]</a><span class="c3">That&#39;s cool!</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref31" id="cmnt31">[ae]</a><span class="c3">Something Dany Santiago pointed out is this may have incremental compilation repercussions. I wonder if relying solely on a status transformer can help us work around that by making it still participate in IC but private in all the relevant ways. Another option could be to annotate them with `@PublishedApi`, though I&#39;m not sure if that explicitly requires them to be `internal` in source too.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref32" id="cmnt32">[af]</a><span class="c3">The more I think about it, I think this is actually fine wrt IC. Adding a new private function alone wouldn&#39;t trigger recompilation, but it _should_ transitively trigger one because a new provider factory class would be generated. Bigger question&nbsp;might be whether or not the new class declaration needs to be generated in FIR first or we need to add metadata to mark it as visible, which we can do</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref33" id="cmnt33">[ag]</a><span class="c3">I like the fact that kotlin-inject has no member injection. Is this really needed?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref34" id="cmnt34">[ah]</a><span class="c3">Deduping this into https://docs.google.com/document/d/1B1Soh0rrVr1BX-Nn2JrZwST5R9afsqBxAS2XNJZFEuE/edit?disco=AAABafDxhkE</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref35" id="cmnt35">[ai]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref36" id="cmnt36">[aj]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref37" id="cmnt37">[ak]</a><span class="c3">If this provider was scoped, will the impl override it to use a scoped provider?</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">By being the component it is both a binding provider and a binding getter.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref38" id="cmnt38">[al]</a><span class="c3">Good point, I guess we should require them to be consistent</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref39" id="cmnt39">[am]</a><span class="c3">Conclusion for now has been to disallow provider overrides</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref40" id="cmnt40">[an]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref41" id="cmnt41">[ao]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref42" id="cmnt42">[ap]</a><span class="c3">Is it OK for a provider to use other property / providers in the component interface? Maybe not good... I guess people can already do that with Dagger modules</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">(Trying to think on the choice of no modules and combining classes that define provisions, with the component to retrieve&nbsp;provisions)</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref43" id="cmnt43">[aq]</a><span class="c3">I think we can advise against it but in general it&#39;s probably not something we should try to write analysis for. We have a lint check in github.com/slackhq/slack-lints that checks for calling providers outside of generated code as an example of checking this elsewhere</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">Daniel Santiago reacted with &#128077; at 2024-12-17 15:40 PM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref44" id="cmnt44">[ar]</a><span class="c3">Added a note advising against it in the providers section</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref45" id="cmnt45">[as]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref46" id="cmnt46">[at]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref47" id="cmnt47">[au]</a><span class="c3">&#128175; on top of the obvious of being explicit what types you are actually providing, ran into a fun issue in kotlin-inject where if you left off the type and called a java function It&#39;d return a platform type which didn&#39;t match with anything and left a very confusing error message.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref48" id="cmnt48">[av]</a><span class="c3">yep. Another technical reason for this is that otherwise the implicit return type is not actually resolved when we generate the declaration in FIR</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref49" id="cmnt49">[aw]</a><span class="c3">I&#39;m thinking with FIR we could eventually move this to be</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">ExampleComponent.create()</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">// Or for factories</span></p><p class="c0"><span class="c3">ExampleComponent.create(...)</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">Brian Norman reacted with &#10133; at 2024-12-18 20:04 PM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref50" id="cmnt50">[ax]</a><span class="c3">This is essentially implemented on main now, but pending figuring out why FIR-generated declarations are not appearing when I test with the K2 plugin</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref51" id="cmnt51">[ay]</a><span class="c3">Is only one component allowed? (No multiple parent?)</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref52" id="cmnt52">[az]</a><span class="c3">Could you unpack that a bit more for me?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref53" id="cmnt53">[ba]</a><span class="c3">Sorry, should have been more clear.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">I see here AppComponent depends on MessageComponent, would it be possible for the create() factory to depend on more than one component?</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Or to ask differently, is this &#39;subcomponents&#39; or &#39;component dependencies&#39; (in terms o Dagger)?</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">It looks like component dependencies.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref54" id="cmnt54">[bb]</a><span class="c3">ah yeah this is component dependencies. Can have multiple!</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref55" id="cmnt55">[bc]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref56" id="cmnt56">[bd]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref57" id="cmnt57">[be]</a><span class="c3">Why are they needed and what&#39;s their value? Can the functions be called inline? I didn&#39;t miss them in kotlin-inject.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref58" id="cmnt58">[bf]</a><span class="c3">kotlin-inject still generates them, it just generates it in each component. This avoids that duplication</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref59" id="cmnt59">[bg]</a><span class="c3">Resolving as answered and adding a bit more context. Feel free to reopen if needed though!</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref60" id="cmnt60">[bh]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref61" id="cmnt61">[bi]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref62" id="cmnt62">[bj]</a><span class="c3">Is this used a lot in practice? I can see value in this only for widely shared libraries, but for nothing else. If any dependency is scoped, then the production components needs the same scope.&nbsp;</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">I liked with Anvil a lot that a everything you provide is added to a specific scope.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref63" id="cmnt63">[bk]</a><span class="c3">fair point, something to think about with the other topic of whether or not to allow overrides. This could just be reserved for contributed interfaces</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref64" id="cmnt64">[bl]</a><span class="c3">(Decided separately to not allow provider overrides)</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref65" id="cmnt65">[bm]</a><span class="c3">This is honestly a very good idea. I think I have an example of this in the kotlin-inject docs somewhere should probably get rid of it.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref66" id="cmnt66">[bn]</a><span class="c3">It can be risky to use private functions because as you noted here they tend to not be visible across compilations and I think that is due to incremental compilation.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Somewhat similar bit us in Room because we analyze private fields and when those are coming from classes that are part of another compilation where the processor does not run it caused inconsistent build failures during incremental compilations.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Maybe the metadata API takes that into account assuming it now exposes some information publicly (in the metadata annotation) of something that was private. But I would be careful if taking strategies that &#39;wouldn&#39;t compile normally&#39;.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref67" id="cmnt67">[bo]</a><span class="c3">Yeah hoping that the combination of that API + using a status transformer to hide access can thread this needle, but will need to test it well. CC Brian Norman</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref68" id="cmnt68">[bp]</a><span class="c3">How much, in general, do you want to rely on FIR to expose generated code? It seems like a lot of the boiler plate here could be avoided if the factory interface was generated in FIR automatically.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref69" id="cmnt69">[bq]</a><span class="c3">I&#39;m open to it if there&#39;s a means to still declare custom factories when needed. We often use base classes with common extensions for factories. That&#39;s a good point that FIR could solve a lot of these</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref70" id="cmnt70">[br]</a><span class="c3">What kind of extensions? Like a `NeedsDurationFactory&lt;T&gt;` interface that has the boilerplate of defining the create function?</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">But it should be pretty easy to see if a @AssistedFactory interface already exists as a nested class and not automatically generate one in that case.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref71" id="cmnt71">[bs]</a><span class="c3">Some of it is boilerplate but some of it is common extensions to factories. For example with Android fragments - you could imagine something like a `create(intent: Intent)` regular creator but then extensions to do `Factory.create(id: String)` that converts that into an intent that passes a user ID in.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">The other tricky thing is that n-number of factories can be generated, they don&#39;t have to be a nested class. Any AssistedFactory-annotated SAM type that returns the target type is valid. But maybe given that we can just always generate a default one and people can define n extras if they want?</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">Brian Norman reacted with &#129300; at 2024-12-18 20:40 PM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref72" id="cmnt72">[bt]</a><span class="c3">Partially implemented in&nbsp;https://github.com/ZacSweers/lattice/pull/60, but behind a flag right now unless there&#39;s a fix for making these generated types appear in the IDE</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref73" id="cmnt73">[bu]</a><span class="c3">Added a note here:&nbsp;https://docs.google.com/document/d/1B1Soh0rrVr1BX-Nn2JrZwST5R9afsqBxAS2XNJZFEuE/edit?pli=1&amp;tab=t.0#heading=h.m7kzefhdvber</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Details the new option but also cases where that option wouldn&#39;t be suitable. Open to suggestions on how to bridge those gaps though! Gonna close this one out in the mean time as partially implemented!</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref74" id="cmnt74">[bv]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref75" id="cmnt75">[bw]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref76" id="cmnt76">[bx]</a><span class="c3">May be my lack of experience building DI tooling, but I&#39;m failing to see why `@Inject` could just be reused here. Or is there some reason to have a separate annotation?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref77" id="cmnt77">[by]</a><span class="c3">Fair point. I suspect dagger does this because it&#39;s technically not JSR-330 compliant on its own, but maybe Dany Santiago can better say</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref78" id="cmnt78">[bz]</a><span class="c3">In Dagger the @AssistedFactory is not required to be a nested class.&nbsp;</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">So if you had an @Inject constructor and one day decide to create an @AssistedFactory in some other file, does it break consumers of the @Inject type (requiring&nbsp;them to go through the factory)? To avoid such issues Dagger went with a new annotation.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref79" id="cmnt79">[ca]</a><span class="c3">interesting, does this mean dagger supports having both a regular and assisted inject annotation on a class?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref80" id="cmnt80">[cb]</a><span class="c3">No, Dagger only allows either @Inject or @AssistedInject in the constructor.</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">Zac Sweers reacted with &#128077; at 2024-12-25 22:04 PM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref81" id="cmnt81">[cc]</a><span class="c3">Thanks for the clarification. Going to prototype supporting just `@Inject` and see how far we can get</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref82" id="cmnt82">[cd]</a><span class="c3">Removed! Just using @Inject now</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref83" id="cmnt83">[ce]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref84" id="cmnt84">[cf]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref85" id="cmnt85">[cg]</a><span class="c3">This seems like it should be a qualifier? Probably super annoying if you have to create the factory yourself. But if it&#39;s done automatically with FIR...</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref86" id="cmnt86">[ch]</a><span class="c3">I think they&#39;re different than qualifiers and it&#39;s probably better to not mix them? I like the explicitness of it and it indicates to the component processor that these dependencies are runtime-provided. This is relevant because the factory gen for this happens independently of the assisted factory impl generation</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">Brian Norman reacted with &#128077; at 2024-12-18 20:39 PM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref87" id="cmnt87">[ci]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref88" id="cmnt88">[cj]</a><span class="c3">_Re-opened_</span></p><p class="c0"><span class="c3">Sorry to re-open this, but I wanted to make clear that my qualifier comment was about the parameter&nbsp;of the `@Assisted` annotation rather than the annotation itself. So instead of `@Assisted(&quot;connect&quot;)` this should maybe be `@Assisted @Named(&quot;connect&quot;)` to keep the ideas separate. But I can definitely see how including an option in `@Assisted` make it easier to use.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref89" id="cmnt89">[ck]</a><span class="c3">ohhhh I gotcha now. Yeah that&#39;s an interesting idea. I&#39;ll add a note/issue for that, the nice thing with this approach is that we could always add that support easily later</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref90" id="cmnt90">[cl]</a><span class="c3">Plus one to Brian&#39;s note. This is an edge case which could be handled for all scenarios with a qualifier; do I always need the assisted annotation in the factory? should i give all my assisted annotations names? what if i put a qualifier in the constructor, but not in the factory, and I get the assisted names right? Vice versa? Lots of thinking that is unnecessary with the existing API in dagger2&#39;s assistedinject.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref91" id="cmnt91">[cm]</a><span class="c3">In kotlin-inject decided to go with making them positional instead of only relying on type/key. The reasoning is they work more like regular function args than something being injected. https://github.com/evant/kotlin-inject/issues/164</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref92" id="cmnt92">[cn]</a><span class="c3">If you auto-generate the factory then I don&#39;t think there can be an ambiguity.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref93" id="cmnt93">[co]</a><span class="c3">yah that&#39;ll hopefully eventually be the standard case, though until IDE support for generated FIR declarations improves I think we can&#39;t rely on it yet</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref94" id="cmnt94">[cp]</a><span class="c3">If this happens, then the name parameters are fantastic. </span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">A good compromise could maybe be something like this:</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">```</span></p><p class="c0"><span class="c3">class MyClass @AssistedInject constructor(</span></p><p class="c0"><span class="c3">&nbsp; @Assisted(&quot;p1&quot;) p1: String,</span></p><p class="c0"><span class="c3">&nbsp; @Assisted(&quot;p2&quot;) p2: Int,</span></p><p class="c0"><span class="c3">) {</span></p><p class="c0"><span class="c3">&nbsp; @AssistedInject.Factory</span></p><p class="c0"><span class="c3">&nbsp; interface MyFactory</span></p><p class="c0"><span class="c3">}</span></p><p class="c0"><span class="c3">```</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Which would preserve an annotation site for the generated case, and an extension site for the interface extension case. </span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Not sure if that&#39;s technically viable, though.</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">Brian Norman reacted with &#10133; at 2025-01-12 04:52 AM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref95" id="cmnt95">[cq]</a><span class="c3">That&#39;s an interesting angle. I think it may be possible, will add a note to the issue tracking it</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref96" id="cmnt96">[cr]</a><span class="c3">My hot take is member injection is always an anti-pattern which is why kotlin-inject doesn&#39;t implement it. &#127798;&#65039;</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref97" id="cmnt97">[cs]</a><span class="c3">haha that&#39;s fair. Sometimes it&#39;s unavoidable, I do plan to emphasize in the final doc that it should be avoided and there&#39;s an FIR warning as well that will flag if you try to have injected members in a constructor-injected class</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref98" id="cmnt98">[ct]</a><span class="c3">So I&#39;m not really a fan of kotlin-inject&#39;s function injection api. This solves a lot of problems with it. The reason I didn&#39;t go with something like this is it means generated code at user call-sites which is awkward with KSP.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref99" id="cmnt99">[cu]</a><span class="c3">I want to say that 98% of our classes are singletons. In Square&#39;s codebase it was similar. Why not flip this and make types singletons by default and have an annotation like `@NoSingleton` or `@NewInstance` to opt-out of this behavior?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref100" id="cmnt100">[cv]</a><span class="c3">hmm I don&#39;t think we&#39;re the same. Probably still a majority, but 98%.&nbsp;My gut feeling is that the lesser evil is to accidentally create more instances than you intend rather than persisting ones longer than you&#39;d expect, but I&#39;d be curious for Jesse and Dany Santiago&#39;s thoughts on this too</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref101" id="cmnt101">[cw]</a><span class="c3">I&#39;m on the opinion that scopes are for correctness more than performance and thus require some reasoning and intent of their life so adding the scope makes that clear, the default&nbsp;being no scope.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref102" id="cmnt102">[cx]</a><span class="c3">Jesse Wilson</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref103" id="cmnt103">[cy]</a><span class="c3">Making this mandatory is interesting. </span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">One thing that dagger supports that I think is of mixed utility is injections that, because they are not bound to a particular graph, are accessible from anywhere. Mandatory scopes would really improve the legibility of the graph here, even if they are a little more boilerplate. And that is a good thing - DI suffers from being too magical and mysterious</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref104" id="cmnt104">[cz]</a><span class="c3">To my point, scoping would still be explicit. But instead of</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">@SingleIn(AppScope::class)</span></p><p class="c0"><span class="c3">@ContributesBinding(AppScope::class)</span></p><p class="c0"><span class="c3">@Inject</span></p><p class="c0"><span class="c3">class Abc : Def</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">I&#39;d like to write </span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">@ContributesBinding(AppScope::class)</span></p><p class="c0"><span class="c3">class Abc : Def</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">The scope is still clear, but everything is a singleton by default. I wouldn&#39;t even go further and say singletons are the ONLY option. If you need your object graph to create a new instance every time, then add a factory and make it explicit (similar to assisted injection without an assisted parameter). </span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">We had memory leaks in our app and solved this through the Factory and making this behavior explicit.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref105" id="cmnt105">[da]</a><span class="c3">What happens to classes with a bare @Inject and no binding?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref106" id="cmnt106">[db]</a><span class="c3">Wait, are we still talking about the same thing? This thread started with making all instances in a component singletons by default. If you use a type in a component that only has an @Inject, then the component still has to instantiate it and can make it a singleton.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">But if you ask about associating a type with a scope explicitly, then one solution could be to write a provider method similar to what you&#39;d need to do with types that you don&#39;t own and that don&#39;t have a @Inject constructor.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref107" id="cmnt107">[dc]</a><span class="c3">&gt; If you use a type in a component that only has an @Inject, then the component still has to instantiate it and can make it a singleton.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Which is why I bring it up. Which component does that object live in? </span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Having it be a global singleton is an option, but....not one I like. Having it be scoped to wherever it happens to be referenced is scary, because it could be referenced from multiple scopes. And those references can change over time. </span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Another option is to have bare @Inject do nothing: an explicit component is required somehow.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref108" id="cmnt108">[dd]</a><span class="c3">I prefer the latter. That is similar to how it works today for classes you don&#39;t own and don&#39;t have an @Inject.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref109" id="cmnt109">[de]</a><span class="c3">Then @Inject can safely be omitted?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref110" id="cmnt110">[df]</a><span class="c3">If the intent is clear through another annotation and there&#39;s only a single constructor, then yes in my opinion. I don&#39;t now if Zac wants to go in this direction, though.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref111" id="cmnt111">[dg]</a><span class="c3">Ofc, absolutely. </span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">In my view it&#39;s worth considering what actually gets made redundant if we make Anvil style hookup a first class citizen. There may be other considerations ofc, but if you&#39;re gonna make a fresh tool...</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">(I personally am less sold on scoped by default than I am on mandatory scoping. Mainly because I am in memory leak head space this past year.)</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref112" id="cmnt112">[dh]</a><span class="c3">KI only supports 0..1 scopes per component, Dagger supports 0..N. This is a big difference and very inconvenient in KI. Worth calling out for Lattice.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref113" id="cmnt113">[di]</a><span class="c3">I&#39;ll update this to specify it matches Dagger &#128077;</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref114" id="cmnt114">[dj]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref115" id="cmnt115">[dk]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref116" id="cmnt116">[dl]</a><span class="c3">Kill this special case and go with the @SingleIn(AppScope) api!</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Not even sure if the notion of &quot;singleton&quot; can even be supported if we don&#39;t distinguish subcomponents from components</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref117" id="cmnt117">[dm]</a><span class="c3">I think you and Ralf Wondratschek have sold me on at least the idea of moving this to an optional/compat annotations lib that includes this&nbsp;&#128077;</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref118" id="cmnt118">[dn]</a><span class="c3">Just checking but I suppose&nbsp;only&nbsp;LazyThreadSafetyMode will be used</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref119" id="cmnt119">[do]</a><span class="c3">I actually have a hybrid implementation, will send it to ya on slack. It essentially matches dagger&#39;s DoubleCheck impl with some kotlin semantics from its synchronized lazy impl</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">Daniel Santiago reacted with &#128077; at 2024-12-17 15:51 PM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref120" id="cmnt120">[dp]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref121" id="cmnt121">[dq]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref122" id="cmnt122">[dr]</a><span class="c3">How come? I would imagine that a Provider of a scoped binding won&#39;t also instantiate the binding (or call the provider) until the first Provider.get(), so I do think for scoped bindings Lazy and Provider are equivalent.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref123" id="cmnt123">[ds]</a><span class="c3">Mostly just explicit semantics. The caller may not (need to) know if the binding is scoped or not but does want to be mindful of it at its use-site.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref124" id="cmnt124">[dt]</a><span class="c3">Why is Lazy needed? Whether an instance should be cached can and should be decided on the provider side. At Square Lazy was more like an anti-pattern and I still agree with that.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref125" id="cmnt125">[du]</a><span class="c3">are you talking about Lazy&lt;Provider&lt;T&gt;&gt; or Lazy in general? Your comment reads like the latter but the comment is on specifically the former</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref126" id="cmnt126">[dv]</a><span class="c3">Lazy in general, but I added the comment here because then you&#39;d avoid this weird things like Lazy&lt;Provider&lt;Abc&gt;&gt; and Provider&lt;Lazy&lt;Abc&gt;&gt;.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref127" id="cmnt127">[dw]</a><span class="c3">This is mostly just for parity with Dagger, I&#39;ve never used it but it&#39;s easy enough to just leave in. I def disagree on Lazy :). It&#39;s pretty crucial to how internal scoped providers work anyway so 98% of the work to support it as an intrinsic is already there anyway</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref128" id="cmnt128">[dx]</a><span class="c3">Internally you could replace this Lazy with Kotlin&#39;s built-in imlementation.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref129" id="cmnt129">[dy]</a><span class="c3">I meant more DoubleCheck. The impl in lattice&#39;s DoubleCheck is a bit of a hybrid impl of both dagger&#39;s and kotlin&#39;s lazy that uses the best of both (multiplatform-friendly concurrency, dagger&#39;s reentrancy checks, avoiding double-wrapping). Basically kotlin&#39;s impl + dagger niceties</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Re: Lazy - I think it&#39;s valuable enough to keep around. You could move it off to consumers, but you could also argue a lot of DI features could be handled by the consumer and I think these affordances for common use cases add up to a smoother experience :). It&#39;d essentially be this case...</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">class Example(foo: Provider&lt;Foo&gt;) {</span></p><p class="c0"><span class="c3">private val foo by lazy(foo)</span></p><p class="c0"><span class="c3">}</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">vs</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">class Example(foo: Lazy&lt;Foo&gt;)</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">...multiplied by every time it&#39;s used. </span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Another factor is that when we support lazy directly, we can skip an intermediary provider for scoped types (which the caller doesn&#39;t need to know about as it&#39;s a decision higher up in the graph). Under the hood a DoubleCheck is used and we can just pass that instance on directly, whereas if we only supported provider it would get re-wrapped by the consumer in a new lazy. Not only that but since DoubleCheck is an internal API, they wouldn&#39;t be able to use it and its &quot;is this delegate already a DoubleCheck?&quot; double-wrapping avoidance.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">ProviderOfLazy I&#39;m less fussed about, but because it&#39;s trivial to support I&#39;m inclined to leave it in as it&#39;s one more bit of feature parity.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">I can dump a bunch of this into the implementation notes for posterity, how does that sound? Basically make it clear why it&#39;s there, and if individual developers don&#39;t want to use that pattern then they can just not use it?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref130" id="cmnt130">[dz]</a><span class="c3">Why have this also be @Provides if the api is different? Why not annotate with @Binds instead?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref131" id="cmnt131">[ea]</a><span class="c3">I think I&#39;m going to add `@Binds` back for this reason and&nbsp;https://docs.google.com/document/d/1B1Soh0rrVr1BX-Nn2JrZwST5R9afsqBxAS2XNJZFEuE/edit?pli=1&amp;disco=AAABadmcMUY</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref132" id="cmnt132">[eb]</a><span class="c3">Resolving, Binds is officially back</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref133" id="cmnt133">[ec]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref134" id="cmnt134">[ed]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref135" id="cmnt135">[ee]</a><span class="c3">I can see this being a foot gun. Could a strict mode be included? I don&#39;t have a good sense for the api utility, so...not sure what direction to push this</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref136" id="cmnt136">[ef]</a><span class="c3">I thought about maybe requiring an `@OptionalDependency`-esque annotation that could be a configurable mode. Would that satisfy what you&#39;re thinking?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref137" id="cmnt137">[eg]</a><span class="c3">Sure! I just don&#39;t want folks adding default params for the unit tests, and then getting surprised when they forget to plug in the live impl</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref138" id="cmnt138">[eh]</a><span class="c3">Ahh good point. Offers two extra thoughts</span></p><p class="c0"><span class="c3">- Such an annotation could be made to only be enforced on classes. Providers already have an implicit expectation that you shouldn&#39;t call them directly</span></p><p class="c0"><span class="c3">- I wonder if there&#39;s an alternative to that mode where you specify this at the constructor level. i.e. we treat inject constructors like we do providers - don&#39;t call them from source. If you want your own, make a test-only one.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref139" id="cmnt139">[ei]</a><span class="c3">After talking with compiler folks, I&#39;m planning to rework this to actually port default value expressions to factories directly and allow components to selectively omit providers as well. That&#39;ll be more compatible with later lowering and avoid guessing target functions</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref140" id="cmnt140">[ej]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref141" id="cmnt141">[ek]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref142" id="cmnt142">[el]</a><span class="c3">Is this optional? The recommendation? The different kind of scopes for aggregation and scoping is confusing. Anvil had no choice given that it was an extension.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">For example, you provide `@Singleton` by default, why not `@SingleIn(scope)`?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref143" id="cmnt143">[em]</a><span class="c3">Currently it&#39;s optional, but usable without an extra annotation or intermediary. I&#39;d be open to making it the recommendation. Did you have something in mind for unifying `@Scope` and anvil scopes in some way?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref144" id="cmnt144">[en]</a><span class="c3">Mostly strongly encouraging these annotations:&nbsp;https://github.com/amzn/kotlin-inject-anvil/tree/main/runtime-optional/src/commonMain/kotlin/software/amazon/lastmile/kotlin/inject/anvil Maybe not enforce, but provide them by default and use them in all samples. Don&#39;t provide `@Singleton`.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref145" id="cmnt145">[eo]</a><span class="c3">I don&#39;t have strong feelings other than the familiarity aspect. Jesse Wilson Dany Santiago thoughts?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref146" id="cmnt146">[ep]</a><span class="c3">I already said it above, but plus one to ralf. The whole notion of singleton is relative anyway.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref147" id="cmnt147">[eq]</a><span class="c3">My biggest concern on the API surface for contributions is answering all the issues that the Anvil haters I spoke with had. </span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">I suspect that you win here by having vastly improved error feedback, but would love to have a word with them again to make sure.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref148" id="cmnt148">[er]</a><span class="c3">Maybe weird comment: what about multiple scopes?</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">We use anvil contributions to juggle different build variants, and being unable to support multiple scopes here is a pain. E.g. AppScope plus DebugInternalAppScope</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref149" id="cmnt149">[es]</a><span class="c3">I suppose it makes sense since graphs can support multiple scope annotations too. Might do something more like this though to keep the simple case simple</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">```</span></p><p class="c0"><span class="c3">@DependencyGraph(AppScope::class)</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">@DependencyGraph(</span></p><p class="c0"><span class="c3">scope = AppScope::class,</span></p><p class="c0"><span class="c3">additionalScopes = [...]</span></p><p class="c0"><span class="c3">)</span></p><p class="c0"><span class="c3">```</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">CC Ralf Wondratschek</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref150" id="cmnt150">[et]</a><span class="c3">@MergeComponent is repeatable for that purpose https://github.com/square/anvil/blob/main/annotations/src/main/java/com/squareup/anvil/annotations/MergeComponent.kt</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref151" id="cmnt151">[eu]</a><span class="c3">TIL</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref152" id="cmnt152">[ev]</a><span class="c3">Right, but we can&#39;t make `@DependencyGraph` repeatable I don&#39;t think</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref153" id="cmnt153">[ew]</a><span class="c3">Solved by adding an `additionalScopes` property to DependencyGraph. Doing this separation so that the common case (one scope) is still the same but the toe-hold is there for more</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref154" id="cmnt154">[ex]</a><span class="c3">If excluding interfaces with providers is a first-class API then maybe disallow provider overrides in general and avoid solving the questions you have for it.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref155" id="cmnt155">[ey]</a><span class="c3">That&#39;s an interesting point. Will see what ralf thinks, I haven&#39;t used kotlin-inject-anvil in a large enough codebase to know how often people use one or the other</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref156" id="cmnt156">[ez]</a><span class="c3">Ralf Wondratschek ^^</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref157" id="cmnt157">[fa]</a><span class="c3">Mentioned this above as well. I think `replaces` and `exclude` are better mechanisms than overriding functions.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref158" id="cmnt158">[fb]</a><span class="c3">Agreed, going to prevent provider overrides for now&nbsp;&#128077;</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref159" id="cmnt159">[fc]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref160" id="cmnt160">[fd]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref161" id="cmnt161">[fe]</a><span class="c3">How does @ContributesBinding interact with scopes and qualifiers?</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">For qualifiers, maybe a type annotation:</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">@ContributesBinding&lt;@Named(&quot;TacoCache&quot;) Cache&gt;(AppScope::class)</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">For scope, maybe similar to qualifier, it goes in the type param.&nbsp;</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">It seems possible to scope the binding but not the impl, in the example of where you want to have two distinct CacheImpl, for two different scoped and qualified Cache bindings.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref162" id="cmnt162">[ff]</a><span class="c3">We could allow them to be on the generic type. In Anvil they just defer to the scope/qualifier annotation on the type itself. Ralf Wondratschek?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref163" id="cmnt163">[fg]</a><span class="c3">I think there is room for improvement here. The subcomponent/component dependency api is weird, it&#39;s a frequent point of noob confusion, the direction of reference is inverted across the two for reasons that make no sense as a user, and it is also a case where I&#39;d argue that having distinct annotations doesn&#39;t help - you just end up having a bunch of duplicate annotations that mean the same thing.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref164" id="cmnt164">[fh]</a><span class="c3">Have you looked at kotlin-inject-anvil&#39;s implementation? It&#39;s more or less an automatic wiring of a component with a dependency, rather than really like dagger&#39;s subcomponents</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref165" id="cmnt165">[fi]</a><span class="c3">1. Interested to see more detail on what the custom annotations API looks like</span></p><p class="c0"><span class="c3">2. Warnings? A migration path would be great</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref166" id="cmnt166">[fj]</a><span class="c3">This is essentially it. The idea would be that if you have a codebase that currently uses a bunch of existing annotations, you can just tell lattice to use those. Do you have suggestions on what else you&#39;d wanna see?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref167" id="cmnt167">[fk]</a><span class="c3">That defeats some of the benefits of Lattice, in particular build time.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref168" id="cmnt168">[fl]</a><span class="c3">Some yes, this is more of a note for people worried about adoption friction. If there&#39;s a desire for writing custom transformers directly we can discuss in the repo &#128077;</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref169" id="cmnt169">[fm]</a><span class="c3">+1</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref170" id="cmnt170">[fn]</a><span class="c3">String and String? are related but different types. I can assign a String to a String?, but not the other way around. I don&#39;t want to call it polymorphism though.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref171" id="cmnt171">[fo]</a><span class="c3">I&#39;m thinking since it is a key part of the language, it should behave like the language, String can satisfy&nbsp;String? but not the other way around. i.e. a special form of optional binding declared by the type nullability.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref172" id="cmnt172">[fp]</a><span class="c3">Some questions that come to mind:</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">- What&#39;s the difference between that and, say, having a String available on the graph but requesting a CharSequence?</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">- Would we enable this by just adding an implicit nullable binds for every type on the graph? Or just when a nullable type is requested, we should check for both the nullable and fall back to the non-null type?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref173" id="cmnt173">[fq]</a><span class="c3">I would scope it to nullability only, say &#39;nullness assignability&#39; and not assignability in general (like the String to CharSequence).</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">My concern is more on the ramifications of having a non-null binding that satisfies nullable requests and one day user adds a nullable provider of same type but totally different value and now all their nullable requests have changed.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">That might be solvable with having the two types considered the same in terms of keys and would cause a multiple binding error.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Similarly requesting a non-null when nullable provider was is not a &#39;missing binding&#39; but more of a &#39;unable to satisfy binding request due to nullability&#39;</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">So I&#39;m think this means &#39;fallback&#39; if &#39;nullness assignability&#39; permits it.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref174" id="cmnt174">[fr]</a><span class="c3">I was leaning towards &quot;just have nullable and non nullable be distinct dep points,&quot; but:</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">&gt; That might be solvable with having the two types considered the same in terms of keys and would cause a multiple binding error.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">I am having a hard time rallying any enthusiasm for supporting the distinction between nullable and non nullable in any dep graph. What good can come of it?</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">If you want both, just add a qualifier for christ&#39;s sake!</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref175" id="cmnt175">[fs]</a><span class="c3">yeah I&#39;m fairly on the fence at the moment and inclined to lean toward initially disallowing nullable types on the graph to start and gathering more community feedback. Easier to add it later than to try to claw it back</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref176" id="cmnt176">[ft]</a><span class="c3">String is a subtype of String? If you don&#39;t match other subtypes then it feels weird to me to special-case those.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref177" id="cmnt177">[fu]</a><span class="c3">My alternative design idea for this is to generate an implicit delegating class of the same name as the function in FIR and make that available to users.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref178" id="cmnt178">[fv]</a><span class="c3">_Marked as resolved_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref179" id="cmnt179">[fw]</a><span class="c3">_Re-opened_</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref180" id="cmnt180">[fx]</a><span class="c3">Some JB compiler folks have pointed me at ways to possibly achieve this</span></p><p class="c0"><span class="c3">1 total reaction</span></p><p class="c0"><span class="c3">Brian Norman reacted with &#128075; at 2024-12-18 21:05 PM</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref181" id="cmnt181">[fy]</a><span class="c3">No</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref182" id="cmnt182">[fz]</a><span class="c3">Jesse had some ideas around this that this is a reference to</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref183" id="cmnt183">[ga]</a><span class="c3">Jesse Wilson</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref184" id="cmnt184">[gb]</a><span class="c3">Our solution to this problem is here: https://speakerdeck.com/vrallev/managing-state-beyond-viewmodels-and-hilt-updated?slide=60 It&#39;s very similar to what Square has. Our Scope abstraction hosts DI components, it hosts a CoroutineScope, but it&#39;s neither the Di component nor CoroutineScope itself. It allows objects to be notified when a scope gets created or destroyed. This is also what allowed us to migrate from Dagger 2 to kotlin-inject a lot easier.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref185" id="cmnt185">[gc]</a><span class="c3">The big concept that CoroutineScope could use is scope specific visibility. E.g. I want to be able to inject unqualified CoroutineScope, and have that resolve to the binding for my exact scope, and nothing else. And vice versa, I want my CoroutineScope binding to not be visible to any graph extensions.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">So: graph private visibility, essentially</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref186" id="cmnt186">[gd]</a><span class="c3">To play devil&#39;s advocate on that - could that be solved by something like a `@ConfineToGraph` API on the provider that instructs the compiler to disallow exposing it as a graph accessor?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref187" id="cmnt187">[ge]</a><span class="c3">Yep, something exactly like that. And it should also prevent leakage to graph extensions.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref188" id="cmnt188">[gf]</a><span class="c3">Neat, filed this to track&nbsp;https://github.com/ZacSweers/lattice/issues/77</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref189" id="cmnt189">[gg]</a><span class="c3">For CoroutineScope we use the @ForScope qualifier again and each component has its own CoroutineScope. You can still inject the CoroutineScope from the parent graph, which has a longer lifecycle, but at least it&#39;s explicit.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref190" id="cmnt190">[gh]</a><span class="c3">Yep, same as what we do. We augment with an SPI plugin that prevents injecting the wrong scope.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref191" id="cmnt191">[gi]</a><span class="c3">Nice! We check in a KSP plugin, which has the same effect.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref192" id="cmnt192">[gj]</a><span class="c3">I had to roll my own for our Anvil validation. Needed something in terms of source files.</span></p><p class="c0 c11"><span class="c3"></span></p><p class="c0"><span class="c3">Providing a sample SPI plugin might suffice if that is supported</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref193" id="cmnt193">[gk]</a><span class="c3">+1</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref194" id="cmnt194">[gl]</a><span class="c3">It&#39;s a power tool for sure, but custom validation is clutch.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref195" id="cmnt195">[gm]</a><span class="c3">Dany Santiago&nbsp;Dagger requires both but curious if it&rsquo;s necessary or if there&rsquo;s ever a case where you have one without the other</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref196" id="cmnt196">[gn]</a><span class="c3">You always need a key with @IntoMap, but having separate allows different types of keys, IntKey, LongKey, ClassKey, StringKey, etc. Also keeps it consistent in terms of the other multibinding data structure annotations, IntoSet, ElementsIntoSet</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref197" id="cmnt197">[go]</a><span class="c3">Hm, if we just considered the presence of a MapKey to be an implicit `@IntoMap`, do you see anything functionally missing in that?</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref198" id="cmnt198">[gp]</a><span class="c3">I don&#39;t see any functionality missing, but some new naming might be required for the key annotations: @IntoMapWithClassKey, @IntoMapWithStringKey, etc</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref199" id="cmnt199">[gq]</a><span class="c3">I don&#39;t know Dagger/Kotlin-Inject well enough to know if this would be something useful in more areas then just components. Thought I would present the idea in case others had thoughts.</span></p></div><div class="c10"><p class="c0"><a href="#cmnt_ref200" id="cmnt200">[gr]</a><span class="c3">Thanks! To add another example from our slack convos - it would be neat if we could change the status of an abstract interface member and implement the body (i.e. val Impl.bind: Instance can become private and managed by the code gen</span></p></div></body></html>