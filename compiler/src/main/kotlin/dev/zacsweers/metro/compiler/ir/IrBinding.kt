// Copyright (C) 2024 Zac Sweers
// SPDX-License-Identifier: Apache-2.0
package dev.zacsweers.metro.compiler.ir

import dev.drewhamilton.poko.Poko
import dev.zacsweers.metro.compiler.MetroAnnotations
import dev.zacsweers.metro.compiler.Symbols
import dev.zacsweers.metro.compiler.capitalizeUS
import dev.zacsweers.metro.compiler.expectAs
import dev.zacsweers.metro.compiler.graph.BaseBinding
import dev.zacsweers.metro.compiler.ir.parameters.Parameter
import dev.zacsweers.metro.compiler.ir.parameters.Parameters
import dev.zacsweers.metro.compiler.isWordPrefixRegex
import dev.zacsweers.metro.compiler.render
import dev.zacsweers.metro.compiler.reportCompilerBug
import dev.zacsweers.metro.compiler.unsafeLazy
import java.util.TreeSet
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrDeclarationWithName
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.declarations.IrValueParameter
import org.jetbrains.kotlin.ir.types.IrSimpleType
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.types.typeOrFail
import org.jetbrains.kotlin.ir.util.callableId
import org.jetbrains.kotlin.ir.util.classId
import org.jetbrains.kotlin.ir.util.dumpKotlinLike
import org.jetbrains.kotlin.ir.util.hasAnnotation
import org.jetbrains.kotlin.ir.util.kotlinFqName
import org.jetbrains.kotlin.ir.util.parentAsClass
import org.jetbrains.kotlin.ir.util.parentClassOrNull
import org.jetbrains.kotlin.ir.util.propertyIfAccessor
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId

internal sealed interface IrBinding : BaseBinding<IrType, IrTypeKey, IrContextualTypeKey> {
  override val typeKey: IrTypeKey
    get() = contextualTypeKey.typeKey

  val scope: IrAnnotation?
  // TODO reconcile parametersByKey vs parameters in collectBindings
  val parametersByKey: Map<IrTypeKey, Parameter>
  // Track the list of parameters, which may not have unique type keys
  val parameters: Parameters
  val nameHint: String
  override val contextualTypeKey: IrContextualTypeKey
  val reportableDeclaration: IrDeclarationWithName?

  /**
   * Returns true if this binding should be scoped (cached) in the graph.
   * For most bindings, this is true if [scope] != null.
   * For [GraphExtension] bindings, this is true if [GraphExtension.extensionScopes] is not empty.
   */
  fun isScoped(): Boolean = scope != null

  override fun renderLocationDiagnostic(): String {
    // First check if we have the contributing file and line number
    return reportableDeclaration?.locationOrNull()?.render()
      // Or the fully-qualified contributing class name
      ?: parametersByKey.entries.firstOrNull()?.key?.toString()
      // Or print the full set of info we know about the binding
      ?: buildString {
        val binding = this@IrBinding
        appendLine("Unknown source location, this may be generated by the compiler.")
        appendLine("└─ Here's some additional information we have for the binding:")
        append("   ├─ Binding type: ")
        appendLine(binding.javaClass.simpleName)
        append("   └─ Binding information: ")
        appendLine(binding)
      }
  }

  sealed interface BindingWithAnnotations : IrBinding {
    val annotations: MetroAnnotations<IrAnnotation>
  }

  sealed interface InjectedClassBinding<T : InjectedClassBinding<T>> :
    BindingWithAnnotations, IrBinding {
    val type: IrClass

    fun withMapKey(mapKey: IrAnnotation?): T
  }

  @Poko
  class ConstructorInjected(
    @Poko.Skip override val type: IrClass,
    @Poko.Skip val classFactory: ClassFactory,
    override val annotations: MetroAnnotations<IrAnnotation>,
    override val typeKey: IrTypeKey,
    val injectedMembers: Set<IrContextualTypeKey>,
  ) : IrBinding, BindingWithAnnotations, InjectedClassBinding<ConstructorInjected> {
    override val parameters: Parameters = classFactory.targetFunctionParameters

    override val parametersByKey: Map<IrTypeKey, Parameter> by unsafeLazy {
      parameters.nonDispatchParameters.associateBy { it.typeKey }
    }

    val isAssisted by unsafeLazy { parameters.regularParameters.any { it.isAssisted } }

    override val dependencies: List<IrContextualTypeKey> by unsafeLazy {
      parameters.nonDispatchParameters.filterNot { it.isAssisted }.map { it.contextualTypeKey } +
        injectedMembers
    }

    override val scope: IrAnnotation?
      get() = annotations.scope

    override val nameHint: String = type.name.asString()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey.create(typeKey)

    override val reportableDeclaration: IrDeclarationWithName?
      get() = type

    fun parameterFor(typeKey: IrTypeKey) =
      classFactory.function.regularParameters.getOrNull(
        parameters.regularParameters.indexOfFirst { it.typeKey == typeKey }
      )

    override fun toString() = buildString {
      append("@Inject ")
      append(typeKey.render(short = true))
    }

    override fun withMapKey(mapKey: IrAnnotation?): ConstructorInjected {
      if (mapKey == null) return this
      return ConstructorInjected(
        type,
        classFactory,
        annotations.copy(mapKeys = annotations.mapKeys + mapKey),
        typeKey,
        injectedMembers,
      )
    }
  }

  class ObjectClass(
    @Poko.Skip override val type: IrClass,
    override val annotations: MetroAnnotations<IrAnnotation>,
    override val typeKey: IrTypeKey,
  ) : IrBinding, BindingWithAnnotations, InjectedClassBinding<ObjectClass> {
    override val dependencies: List<IrContextualTypeKey> = emptyList()
    override val scope: IrAnnotation? = null
    override val parameters: Parameters = Parameters.empty()
    override val parametersByKey: Map<IrTypeKey, Parameter> = emptyMap()

    override val nameHint: String = type.name.asString()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey.create(typeKey)

    override val reportableDeclaration: IrDeclarationWithName?
      get() = type

    override fun toString() = buildString {
      append("@Inject ")
      append(typeKey.render(short = true))
    }

    override fun withMapKey(mapKey: IrAnnotation?): ObjectClass {
      if (mapKey == null) return this
      return ObjectClass(type, annotations.copy(mapKeys = annotations.mapKeys + mapKey), typeKey)
    }
  }

  /** A binding that is statically defined in a graph or binding container. */
  sealed interface StaticBinding : IrBinding, BindingWithAnnotations

  @Poko
  class Provided(
    @Poko.Skip val providerFactory: ProviderFactory,
    override val annotations: MetroAnnotations<IrAnnotation>,
    override val contextualTypeKey: IrContextualTypeKey,
    override val parameters: Parameters,
  ) : StaticBinding {
    override val dependencies: List<IrContextualTypeKey> by unsafeLazy {
      parameters.allParameters.map { it.contextualTypeKey }
    }

    override val parametersByKey: Map<IrTypeKey, Parameter> =
      parameters.nonDispatchParameters.associateBy { it.typeKey }

    override val scope: IrAnnotation?
      get() = annotations.scope

    val intoSet: Boolean
      get() = annotations.isIntoSet

    val elementsIntoSet: Boolean
      get() = annotations.isElementsIntoSet

    // TODO are both necessary? Is there any case where only one is specified?
    val intoMap: Boolean
      get() = annotations.isIntoMap

    val mapKey: IrAnnotation? = annotations.mapKeys.singleOrNull()
    override val typeKey: IrTypeKey = contextualTypeKey.typeKey

    val isIntoMultibinding
      get() = annotations.isIntoMultibinding

    override val nameHint: String = providerFactory.callableId.callableName.asString()

    override val reportableDeclaration: IrDeclarationWithName?
      get() = providerFactory.function

    fun parameterFor(typeKey: IrTypeKey): IrValueParameter {
      return parameters.allParameters.find { it.typeKey == typeKey }?.ir
        ?: error(
          "No value parameter found for key $typeKey in ${providerFactory.callableId.asSingleFqName().asString()}."
        )
    }

    override fun toString() = buildString {
      append("@Provides ")
      if (intoSet) {
        append("@IntoSet ")
      } else if (elementsIntoSet) {
        append("@ElementsIntoSet ")
      } else if (intoMap || mapKey != null) {
        append("@IntoMap ")
        mapKey?.let {
          append(it.toString())
          append(' ')
        }
      }
      append(
        providerFactory.callableId.render(
          short = false,
          isProperty = providerFactory.isPropertyAccessor,
        )
      )
      append(": ")
      append(typeKey.render(short = false))
    }
  }

  /** Represents an aliased binding, i.e. `@Binds`. Can be a multibinding. */
  @Poko
  class Alias(
    override val typeKey: IrTypeKey,
    val aliasedType: IrTypeKey,
    val bindsCallable: BindsCallable?,
    override val parameters: Parameters,
  ) : StaticBinding {
    val ir = bindsCallable?.function
    override val annotations: MetroAnnotations<IrAnnotation> =
      bindsCallable?.callableMetadata?.annotations ?: MetroAnnotations.none()

    init {
      if (ir != null && !annotations.isBinds) {
        error("Aliases must be binds!")
      }
    }

    fun aliasedBinding(graph: IrBindingGraph, stack: IrBindingStack): IrBinding {
      // O(1) lookup at this point
      return graph.requireBinding(contextualTypeKey.withTypeKey(aliasedType), stack)
    }

    override val scope: IrAnnotation? = null
    override val parametersByKey: Map<IrTypeKey, Parameter> =
      parameters.nonDispatchParameters.associateBy { it.typeKey }
    override val dependencies: List<IrContextualTypeKey> =
      listOf(IrContextualTypeKey.create(aliasedType))
    override val nameHint: String = ir?.name?.asString() ?: typeKey.type.rawType().name.asString()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)
    // TODO dedupe with the below render()
    override val reportableDeclaration: IrDeclarationWithName?
      get() {
        if (ir == null) return null
        return (ir.overriddenSymbolsSequence().lastOrNull()?.owner ?: ir).let {
          val isMetroContribution =
            it.parentClassOrNull?.hasAnnotation(Symbols.ClassIds.metroContribution) == true
          if (isMetroContribution) {
            // If it's a contribution, the source is
            // SourceClass.$$MetroContributionScopeName.bindingFunction
            //                                          ^^^
            it.parentAsClass.parentAsClass
          } else {
            it
          }
        }
      }

    override fun renderLocationDiagnostic(): String {
      if ((annotations.isIntoMultibinding || annotations.isBinds) && ir != null) {
        (ir.overriddenSymbolsSequence().lastOrNull()?.owner ?: ir).let {
          val isMetroContribution =
            it.parentClassOrNull?.hasAnnotation(Symbols.ClassIds.metroContribution) == true
          if (isMetroContribution) {
            // If it's a contribution, the source is
            // SourceClass.$$MetroContributionScopeName.bindingFunction
            //                                          ^^^
            return buildString {
              append("Contributed by '")
              append(it.parentAsClass.parentAsClass.kotlinFqName)
              append('\'')
              it.parentAsClass.parentAsClass.locationOrNull()?.let { location ->
                append(" at ")
                append(location.render())
              } ?: run { append(" at an unknown source location (likely a separate compilation).") }
            }
          }
        }
      }
      return super<StaticBinding>.renderLocationDiagnostic()
    }

    override fun toString() = buildString {
      if (annotations.isBinds) {
        append("@Binds ")
      } else if (ir == null) {
        // This is a synthetic alias
        append("@Binds /* synthetic */ ")
      }
      if (annotations.isIntoSet) {
        append("@IntoSet ")
      } else if (annotations.isElementsIntoSet) {
        append("@ElementsIntoSet ")
      } else if (annotations.isIntoMap || annotations.mapKeys.isNotEmpty()) {
        append("@IntoMap ")
        annotations.mapKeys.firstOrNull()?.let {
          append(it.toString())
          append(' ')
        }
      }
      append(aliasedType.render(short = true))
      append('.')
      append(nameHint)
      append(": ")
      append(typeKey.render(short = true))
    }
  }

  @Poko
  class Assisted(
    @Poko.Skip override val type: IrClass,
    val target: IrContextualTypeKey,
    @Poko.Skip val function: IrSimpleFunction,
    override val annotations: MetroAnnotations<IrAnnotation>,
    override val parameters: Parameters,
    override val typeKey: IrTypeKey,
  ) : IrBinding, BindingWithAnnotations, InjectedClassBinding<Assisted> {
    // Dependencies are handled by the target class
    override val dependencies: List<IrContextualTypeKey> = listOf(target)
    override val parametersByKey: Map<IrTypeKey, Parameter> = emptyMap()
    override val nameHint: String = type.name.asString()
    override val scope: IrAnnotation? = null
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)
    override val reportableDeclaration: IrDeclarationWithName?
      get() = type

    override val isImplicitlyDeferrable: Boolean = true

    override fun withMapKey(mapKey: IrAnnotation?): Assisted {
      if (mapKey == null) return this
      return Assisted(
        type,
        target,
        function,
        annotations.copy(mapKeys = annotations.mapKeys + mapKey),
        parameters,
        typeKey,
      )
    }
  }

  data class BoundInstance(
    override val typeKey: IrTypeKey,
    override val nameHint: String,
    override val reportableDeclaration: IrDeclarationWithName?,
  ) : IrBinding {
    constructor(
      parameter: Parameter,
      reportableLocation: IrDeclarationWithName,
    ) : this(parameter.typeKey, "${parameter.name.asString()}Instance", reportableLocation)

    override val dependencies: List<IrContextualTypeKey> = emptyList()
    override val scope: IrAnnotation? = null
    override val parametersByKey: Map<IrTypeKey, Parameter> = emptyMap()
    override val parameters: Parameters = Parameters.empty()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)
  }

  data class Absent(override val typeKey: IrTypeKey) : IrBinding {
    override val dependencies: List<IrContextualTypeKey> = emptyList()
    override val scope: IrAnnotation? = null
    override val nameHint: String
      get() = error("Should never be called")

    override val parametersByKey: Map<IrTypeKey, Parameter> = emptyMap()
    override val parameters: Parameters = Parameters.empty()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)

    override val reportableDeclaration: IrDeclarationWithName? = null
    override val isTransient: Boolean = true
  }

  @Poko
  class GraphDependency(
    val ownerKey: IrTypeKey,
    @Poko.Skip val graph: IrClass,
    @Poko.Skip val getter: IrSimpleFunction,
    val isProviderFieldAccessor: Boolean,
    override val typeKey: IrTypeKey,
    val callableId: CallableId = getter.callableId,
  ) : IrBinding {
    override val dependencies: List<IrContextualTypeKey> = listOf(IrContextualTypeKey(ownerKey))
    override val scope: IrAnnotation? = null
    override val nameHint: String = buildString {
      append(graph.name)
      val property = getter.correspondingPropertySymbol
      if (property != null) {
        val propName = property.owner.name.asString()
        if (!isWordPrefixRegex.matches(propName)) {
          append("Get")
        }
        append(propName.capitalizeUS())
      } else {
        append(getter.name.capitalizeUS())
      }
    }
    override val parametersByKey: Map<IrTypeKey, Parameter> = emptyMap()
    override val parameters: Parameters = Parameters.empty()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)

    override val reportableDeclaration: IrDeclarationWithName?
      get() = getter.propertyIfAccessor.expectAs<IrDeclarationWithName>()

    override fun toString(): String {
      return "${graph.kotlinFqName}#${(getter.propertyIfAccessor as IrDeclarationWithName).name}: ${getter.returnType.dumpKotlinLike()}"
    }
  }

  // TODO sets
  //  unscoped always initializes inline? Dagger sometimes generates private getters
  //  - @multibinds methods can never be scoped
  @Poko
  class Multibinding(
    override val typeKey: IrTypeKey,
    /** The original `@Multibinds` declaration, if any. Note this may point at a fake override. */
    @Poko.Skip var declaration: IrSimpleFunction?,
    val isSet: Boolean,
    val isMap: Boolean,
    /** Corresponds to @MultibindsElement.bindingId */
    val bindingId: String,
    var allowEmpty: Boolean,
    // Reconcile this with parametersByKey?
    // TreeSet sorting for consistency
    val sourceBindings: MutableSet<IrTypeKey> = TreeSet(),
  ) : IrBinding {
    override val scope: IrAnnotation? = null
    override val dependencies by unsafeLazy { sourceBindings.map { IrContextualTypeKey(it) } }
    override val parametersByKey: Map<IrTypeKey, Parameter> = emptyMap()
    override val parameters: Parameters = Parameters.empty()

    override val nameHint: String
      get() = "${typeKey.type.rawType().name}Multibinding"

    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)

    override val reportableDeclaration: IrDeclarationWithName? = declaration

    fun addSourceBinding(source: IrTypeKey) {
      if (source in sourceBindings) {
        reportCompilerBug("Duplicate multibinding source: $source")
      }
      sourceBindings.add(source)
    }

    companion object {
      /**
       * Special case! Multibindings may be created under two conditions:
       * 1. Explicitly via `@Multibinds`
       * 2. Implicitly via a `@Provides` callable that contributes into a multibinding
       *
       * Because these may both happen, if the key already exists in the graph we won't try to add
       * it again
       */
      context(context: IrMetroContext)
      fun fromMultibindsDeclaration(
        getter: IrSimpleFunction,
        multibinds: IrAnnotation,
        contextualTypeKey: IrContextualTypeKey,
      ): Multibinding {
        return create(
          typeKey = contextualTypeKey.typeKey,
          declaration = getter,
          allowEmpty = multibinds.allowEmpty(),
        )
      }

      context(context: IrMetroContext)
      fun fromContributor(multibindingTypeKey: IrTypeKey): Multibinding {
        return create(typeKey = multibindingTypeKey, declaration = null, allowEmpty = false)
      }

      context(context: IrMetroContext)
      private fun create(
        typeKey: IrTypeKey,
        declaration: IrSimpleFunction?,
        allowEmpty: Boolean = false,
      ): Multibinding {
        val rawType = typeKey.type.rawType()

        val isSet = rawType.implements(context.irBuiltIns.setClass.owner.classId!!)
        val isMap = !isSet

        val bindingId: String =
          if (isMap) {
            val keyType = typeKey.type.expectAs<IrSimpleType>().arguments[0].typeOrFail
            createMapBindingId(keyType, typeKey)
          } else {
            typeKey.multibindingId
          }

        return Multibinding(
          typeKey,
          isSet = isSet,
          isMap = isMap,
          bindingId = bindingId,
          allowEmpty = allowEmpty,
          declaration = declaration,
        )
      }
    }
  }

  data class MembersInjected(
    // Always MembersInjected<TargetClass>
    override val contextualTypeKey: IrContextualTypeKey,
    override val parameters: Parameters,
    override val reportableDeclaration: IrDeclarationWithName?,
    // Only present for inject() functions
    val function: IrFunction?,
    val isFromInjectorFunction: Boolean,
    val targetClassId: ClassId,
  ) : IrBinding {
    override val typeKey: IrTypeKey = contextualTypeKey.typeKey

    override val dependencies: List<IrContextualTypeKey> =
      parameters.nonDispatchParameters
        // Instance parameters are implicitly assisted in this scenario and marked as such in FIR
        .filterNot { it.isAssisted }
        .map { it.contextualTypeKey }

    override val parametersByKey: Map<IrTypeKey, Parameter> =
      parameters.nonDispatchParameters.associateBy { it.typeKey }

    override val scope: IrAnnotation? = null

    override val nameHint: String = "${typeKey.type.rawType().name}MembersInjector"
  }

  /**
   * Represents a graph extension binding. Graph extensions are treated as bindings to enable
   * standard code generation for scoped instances when the extension graph itself is scoped.
   */
  @Poko
  class GraphExtension(
    override val typeKey: IrTypeKey,
    val accessor: IrSimpleFunction,
    val extensionScopes: Set<IrAnnotation>,
  ) : IrBinding {
    override val reportableDeclaration: IrDeclarationWithName = accessor
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)
    override val dependencies: List<IrContextualTypeKey> = emptyList()
    override val parameters: Parameters = Parameters.empty()
    override val parametersByKey: Map<IrTypeKey, Parameter> = emptyMap()

    // The scope field always returns null for GraphExtension
    // Use shouldBeScoped to check if this binding needs to be scoped
    override val scope: IrAnnotation? = null

    override val nameHint: String = typeKey.type.rawType().name.asString()

    /**
     * Returns true if this graph extension should be scoped (cached) in the parent graph.
     * A graph extension is scoped if it has any extension scopes defined.
     */
    override fun isScoped(): Boolean = extensionScopes.isNotEmpty()
  }
}
